{
  "version": 3,
  "sources": ["../../@lexical/mark/LexicalMark.dev.js", "../../@lexical/mark/LexicalMark.js", "../../@lexical/react/LexicalTreeView.dev.js", "../../@lexical/react/LexicalTreeView.js"],
  "sourcesContent": ["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar lexical = require('lexical');\nvar utils = require('@lexical/utils');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n/** @noInheritDoc */\nclass MarkNode extends lexical.ElementNode {\n  /** @internal */\n\n  static getType() {\n    return 'mark';\n  }\n  static clone(node) {\n    return new MarkNode(Array.from(node.__ids), node.__key);\n  }\n  static importDOM() {\n    return null;\n  }\n  static importJSON(serializedNode) {\n    const node = $createMarkNode(serializedNode.ids);\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      ids: this.getIDs(),\n      type: 'mark',\n      version: 1\n    };\n  }\n  constructor(ids, key) {\n    super(key);\n    this.__ids = ids || [];\n  }\n  createDOM(config) {\n    const element = document.createElement('mark');\n    utils.addClassNamesToElement(element, config.theme.mark);\n    if (this.__ids.length > 1) {\n      utils.addClassNamesToElement(element, config.theme.markOverlap);\n    }\n    return element;\n  }\n  updateDOM(prevNode, element, config) {\n    const prevIDs = prevNode.__ids;\n    const nextIDs = this.__ids;\n    const prevIDsCount = prevIDs.length;\n    const nextIDsCount = nextIDs.length;\n    const overlapTheme = config.theme.markOverlap;\n    if (prevIDsCount !== nextIDsCount) {\n      if (prevIDsCount === 1) {\n        if (nextIDsCount === 2) {\n          utils.addClassNamesToElement(element, overlapTheme);\n        }\n      } else if (nextIDsCount === 1) {\n        utils.removeClassNamesFromElement(element, overlapTheme);\n      }\n    }\n    return false;\n  }\n  hasID(id) {\n    const ids = this.getIDs();\n    for (let i = 0; i < ids.length; i++) {\n      if (id === ids[i]) {\n        return true;\n      }\n    }\n    return false;\n  }\n  getIDs() {\n    const self = this.getLatest();\n    return $isMarkNode(self) ? self.__ids : [];\n  }\n  addID(id) {\n    const self = this.getWritable();\n    if ($isMarkNode(self)) {\n      const ids = self.__ids;\n      self.__ids = ids;\n      for (let i = 0; i < ids.length; i++) {\n        // If we already have it, don't add again\n        if (id === ids[i]) return;\n      }\n      ids.push(id);\n    }\n  }\n  deleteID(id) {\n    const self = this.getWritable();\n    if ($isMarkNode(self)) {\n      const ids = self.__ids;\n      self.__ids = ids;\n      for (let i = 0; i < ids.length; i++) {\n        if (id === ids[i]) {\n          ids.splice(i, 1);\n          return;\n        }\n      }\n    }\n  }\n  insertNewAfter(selection, restoreSelection = true) {\n    const element = this.getParentOrThrow().insertNewAfter(selection, restoreSelection);\n    if (lexical.$isElementNode(element)) {\n      const markNode = $createMarkNode(this.__ids);\n      element.append(markNode);\n      return markNode;\n    }\n    return null;\n  }\n  canInsertTextBefore() {\n    return false;\n  }\n  canInsertTextAfter() {\n    return false;\n  }\n  canBeEmpty() {\n    return false;\n  }\n  isInline() {\n    return true;\n  }\n  extractWithChild(child, selection, destination) {\n    if (!lexical.$isRangeSelection(selection) || destination === 'html') {\n      return false;\n    }\n    const anchor = selection.anchor;\n    const focus = selection.focus;\n    const anchorNode = anchor.getNode();\n    const focusNode = focus.getNode();\n    const isBackward = selection.isBackward();\n    const selectionLength = isBackward ? anchor.offset - focus.offset : focus.offset - anchor.offset;\n    return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && this.getTextContent().length === selectionLength;\n  }\n  excludeFromCopy(destination) {\n    return destination !== 'clone';\n  }\n}\nfunction $createMarkNode(ids) {\n  return lexical.$applyNodeReplacement(new MarkNode(ids));\n}\nfunction $isMarkNode(node) {\n  return node instanceof MarkNode;\n}\n\n/** @module @lexical/mark */\nfunction $unwrapMarkNode(node) {\n  const children = node.getChildren();\n  let target = null;\n  for (let i = 0; i < children.length; i++) {\n    const child = children[i];\n    if (target === null) {\n      node.insertBefore(child);\n    } else {\n      target.insertAfter(child);\n    }\n    target = child;\n  }\n  node.remove();\n}\nfunction $wrapSelectionInMarkNode(selection, isBackward, id, createNode) {\n  const nodes = selection.getNodes();\n  const anchorOffset = selection.anchor.offset;\n  const focusOffset = selection.focus.offset;\n  const nodesLength = nodes.length;\n  const startOffset = isBackward ? focusOffset : anchorOffset;\n  const endOffset = isBackward ? anchorOffset : focusOffset;\n  let currentNodeParent;\n  let lastCreatedMarkNode;\n\n  // We only want wrap adjacent text nodes, line break nodes\n  // and inline element nodes. For decorator nodes and block\n  // element nodes, we step out of their boundary and start\n  // again after, if there are more nodes.\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n    if (lexical.$isElementNode(lastCreatedMarkNode) && lastCreatedMarkNode.isParentOf(node)) {\n      // If the current node is a child of the last created mark node, there is nothing to do here\n      continue;\n    }\n    const isFirstNode = i === 0;\n    const isLastNode = i === nodesLength - 1;\n    let targetNode = null;\n    if (lexical.$isTextNode(node)) {\n      // Case 1: The node is a text node and we can split it\n      const textContentSize = node.getTextContentSize();\n      const startTextOffset = isFirstNode ? startOffset : 0;\n      const endTextOffset = isLastNode ? endOffset : textContentSize;\n      if (startTextOffset === 0 && endTextOffset === 0) {\n        continue;\n      }\n      const splitNodes = node.splitText(startTextOffset, endTextOffset);\n      targetNode = splitNodes.length > 1 && (splitNodes.length === 3 || isFirstNode && !isLastNode || endTextOffset === textContentSize) ? splitNodes[1] : splitNodes[0];\n    } else if ($isMarkNode(node)) {\n      // Case 2: the node is a mark node and we can ignore it as a target,\n      // moving on to its children. Note that when we make a mark inside\n      // another mark, it may utlimately be unnested by a call to\n      // `registerNestedElementResolver<MarkNode>` somewhere else in the\n      // codebase.\n\n      continue;\n    } else if (lexical.$isElementNode(node) && node.isInline()) {\n      // Case 3: inline element nodes can be added in their entirety to the new\n      // mark\n      targetNode = node;\n    }\n    if (targetNode !== null) {\n      // Now that we have a target node for wrapping with a mark, we can run\n      // through special cases.\n      if (targetNode && targetNode.is(currentNodeParent)) {\n        // The current node is a child of the target node to be wrapped, there\n        // is nothing to do here.\n        continue;\n      }\n      const parentNode = targetNode.getParent();\n      if (parentNode == null || !parentNode.is(currentNodeParent)) {\n        // If the parent node is not the current node's parent node, we can\n        // clear the last created mark node.\n        lastCreatedMarkNode = undefined;\n      }\n      currentNodeParent = parentNode;\n      if (lastCreatedMarkNode === undefined) {\n        // If we don't have a created mark node, we can make one\n        const createMarkNode = createNode || $createMarkNode;\n        lastCreatedMarkNode = createMarkNode([id]);\n        targetNode.insertBefore(lastCreatedMarkNode);\n      }\n\n      // Add the target node to be wrapped in the latest created mark node\n      lastCreatedMarkNode.append(targetNode);\n    } else {\n      // If we don't have a target node to wrap we can clear our state and\n      // continue on with the next node\n      currentNodeParent = undefined;\n      lastCreatedMarkNode = undefined;\n    }\n  }\n  // Make selection collapsed at the end\n  if (lexical.$isElementNode(lastCreatedMarkNode)) {\n    // eslint-disable-next-line no-unused-expressions\n    isBackward ? lastCreatedMarkNode.selectStart() : lastCreatedMarkNode.selectEnd();\n  }\n}\nfunction $getMarkIDs(node, offset) {\n  let currentNode = node;\n  while (currentNode !== null) {\n    if ($isMarkNode(currentNode)) {\n      return currentNode.getIDs();\n    } else if (lexical.$isTextNode(currentNode) && offset === currentNode.getTextContentSize()) {\n      const nextSibling = currentNode.getNextSibling();\n      if ($isMarkNode(nextSibling)) {\n        return nextSibling.getIDs();\n      }\n    }\n    currentNode = currentNode.getParent();\n  }\n  return null;\n}\n\nexports.$createMarkNode = $createMarkNode;\nexports.$getMarkIDs = $getMarkIDs;\nexports.$isMarkNode = $isMarkNode;\nexports.$unwrapMarkNode = $unwrapMarkNode;\nexports.$wrapSelectionInMarkNode = $wrapSelectionInMarkNode;\nexports.MarkNode = MarkNode;\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict'\nconst LexicalMark = process.env.NODE_ENV === 'development' ? require('./LexicalMark.dev.js') : require('./LexicalMark.prod.js')\nmodule.exports = LexicalMark;", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar html = require('@lexical/html');\nvar link = require('@lexical/link');\nvar mark = require('@lexical/mark');\nvar utils = require('@lexical/utils');\nvar lexical = require('lexical');\nvar React = require('react');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst NON_SINGLE_WIDTH_CHARS_REPLACEMENT = Object.freeze({\n  '\\t': '\\\\t',\n  '\\n': '\\\\n'\n});\nconst NON_SINGLE_WIDTH_CHARS_REGEX = new RegExp(Object.keys(NON_SINGLE_WIDTH_CHARS_REPLACEMENT).join('|'), 'g');\nconst SYMBOLS = Object.freeze({\n  ancestorHasNextSibling: '|',\n  ancestorIsLastChild: ' ',\n  hasNextSibling: '├',\n  isLastChild: '└',\n  selectedChar: '^',\n  selectedLine: '>'\n});\nfunction TreeView({\n  treeTypeButtonClassName,\n  timeTravelButtonClassName,\n  timeTravelPanelSliderClassName,\n  timeTravelPanelButtonClassName,\n  viewClassName,\n  timeTravelPanelClassName,\n  editor\n}) {\n  const [timeStampedEditorStates, setTimeStampedEditorStates] = React.useState([]);\n  const [content, setContent] = React.useState('');\n  const [timeTravelEnabled, setTimeTravelEnabled] = React.useState(false);\n  const [showExportDOM, setShowExportDOM] = React.useState(false);\n  const playingIndexRef = React.useRef(0);\n  const treeElementRef = React.useRef(null);\n  const inputRef = React.useRef(null);\n  const [isPlaying, setIsPlaying] = React.useState(false);\n  const [isLimited, setIsLimited] = React.useState(false);\n  const [showLimited, setShowLimited] = React.useState(false);\n  const lastEditorStateRef = React.useRef(null);\n  const commandsLog = useLexicalCommandsLog(editor);\n  const generateTree = React.useCallback(editorState => {\n    const treeText = generateContent(editor, commandsLog, showExportDOM);\n    setContent(treeText);\n    if (!timeTravelEnabled) {\n      setTimeStampedEditorStates(currentEditorStates => [...currentEditorStates, [Date.now(), editorState]]);\n    }\n  }, [commandsLog, editor, timeTravelEnabled, showExportDOM]);\n  React.useEffect(() => {\n    const editorState = editor.getEditorState();\n    if (!showLimited && editorState._nodeMap.size < 1000) {\n      setContent(generateContent(editor, commandsLog, showExportDOM));\n    }\n  }, [commandsLog, editor, showLimited, showExportDOM]);\n  React.useEffect(() => {\n    return utils.mergeRegister(editor.registerUpdateListener(({\n      editorState\n    }) => {\n      if (!showLimited && editorState._nodeMap.size > 1000) {\n        lastEditorStateRef.current = editorState;\n        setIsLimited(true);\n        if (!showLimited) {\n          return;\n        }\n      }\n      generateTree(editorState);\n    }), editor.registerEditableListener(() => {\n      const treeText = generateContent(editor, commandsLog, showExportDOM);\n      setContent(treeText);\n    }));\n  }, [commandsLog, editor, showExportDOM, isLimited, generateTree, showLimited]);\n  const totalEditorStates = timeStampedEditorStates.length;\n  React.useEffect(() => {\n    if (isPlaying) {\n      let timeoutId;\n      const play = () => {\n        const currentIndex = playingIndexRef.current;\n        if (currentIndex === totalEditorStates - 1) {\n          setIsPlaying(false);\n          return;\n        }\n        const currentTime = timeStampedEditorStates[currentIndex][0];\n        const nextTime = timeStampedEditorStates[currentIndex + 1][0];\n        const timeDiff = nextTime - currentTime;\n        timeoutId = setTimeout(() => {\n          playingIndexRef.current++;\n          const index = playingIndexRef.current;\n          const input = inputRef.current;\n          if (input !== null) {\n            input.value = String(index);\n          }\n          editor.setEditorState(timeStampedEditorStates[index][1]);\n          play();\n        }, timeDiff);\n      };\n      play();\n      return () => {\n        clearTimeout(timeoutId);\n      };\n    }\n  }, [timeStampedEditorStates, isPlaying, editor, totalEditorStates]);\n  React.useEffect(() => {\n    const element = treeElementRef.current;\n    if (element !== null) {\n      // @ts-ignore Internal field\n      element.__lexicalEditor = editor;\n      return () => {\n        // @ts-ignore Internal field\n        element.__lexicalEditor = null;\n      };\n    }\n  }, [editor]);\n  return /*#__PURE__*/React.createElement(\"div\", {\n    className: viewClassName\n  }, !showLimited && isLimited ? /*#__PURE__*/React.createElement(\"div\", {\n    style: {\n      padding: 20\n    }\n  }, /*#__PURE__*/React.createElement(\"span\", {\n    style: {\n      marginRight: 20\n    }\n  }, \"Detected large EditorState, this can impact debugging performance.\"), /*#__PURE__*/React.createElement(\"button\", {\n    onClick: () => {\n      setShowLimited(true);\n      const editorState = lastEditorStateRef.current;\n      if (editorState !== null) {\n        lastEditorStateRef.current = null;\n        generateTree(editorState);\n      }\n    },\n    style: {\n      background: 'transparent',\n      border: '1px solid white',\n      color: 'white',\n      cursor: 'pointer',\n      padding: 5\n    }\n  }, \"Show full tree\")) : null, !showLimited ? /*#__PURE__*/React.createElement(\"button\", {\n    onClick: () => setShowExportDOM(!showExportDOM),\n    className: treeTypeButtonClassName,\n    type: \"button\"\n  }, showExportDOM ? 'Tree' : 'Export DOM') : null, !timeTravelEnabled && (showLimited || !isLimited) && totalEditorStates > 2 && /*#__PURE__*/React.createElement(\"button\", {\n    onClick: () => {\n      const rootElement = editor.getRootElement();\n      if (rootElement !== null) {\n        rootElement.contentEditable = 'false';\n        playingIndexRef.current = totalEditorStates - 1;\n        setTimeTravelEnabled(true);\n      }\n    },\n    className: timeTravelButtonClassName,\n    type: \"button\"\n  }, \"Time Travel\"), (showLimited || !isLimited) && /*#__PURE__*/React.createElement(\"pre\", {\n    ref: treeElementRef\n  }, content), timeTravelEnabled && (showLimited || !isLimited) && /*#__PURE__*/React.createElement(\"div\", {\n    className: timeTravelPanelClassName\n  }, /*#__PURE__*/React.createElement(\"button\", {\n    className: timeTravelPanelButtonClassName,\n    onClick: () => {\n      if (playingIndexRef.current === totalEditorStates - 1) {\n        playingIndexRef.current = 1;\n      }\n      setIsPlaying(!isPlaying);\n    },\n    type: \"button\"\n  }, isPlaying ? 'Pause' : 'Play'), /*#__PURE__*/React.createElement(\"input\", {\n    className: timeTravelPanelSliderClassName,\n    ref: inputRef,\n    onChange: event => {\n      const editorStateIndex = Number(event.target.value);\n      const timeStampedEditorState = timeStampedEditorStates[editorStateIndex];\n      if (timeStampedEditorState) {\n        playingIndexRef.current = editorStateIndex;\n        editor.setEditorState(timeStampedEditorState[1]);\n      }\n    },\n    type: \"range\",\n    min: \"1\",\n    max: totalEditorStates - 1\n  }), /*#__PURE__*/React.createElement(\"button\", {\n    className: timeTravelPanelButtonClassName,\n    onClick: () => {\n      const rootElement = editor.getRootElement();\n      if (rootElement !== null) {\n        rootElement.contentEditable = 'true';\n        const index = timeStampedEditorStates.length - 1;\n        const timeStampedEditorState = timeStampedEditorStates[index];\n        editor.setEditorState(timeStampedEditorState[1]);\n        const input = inputRef.current;\n        if (input !== null) {\n          input.value = String(index);\n        }\n        setTimeTravelEnabled(false);\n        setIsPlaying(false);\n      }\n    },\n    type: \"button\"\n  }, \"Exit\")));\n}\nfunction useLexicalCommandsLog(editor) {\n  const [loggedCommands, setLoggedCommands] = React.useState([]);\n  React.useEffect(() => {\n    const unregisterCommandListeners = new Set();\n    for (const [command] of editor._commands) {\n      unregisterCommandListeners.add(editor.registerCommand(command, payload => {\n        setLoggedCommands(state => {\n          const newState = [...state];\n          newState.push({\n            payload,\n            type: command.type ? command.type : 'UNKNOWN'\n          });\n          if (newState.length > 10) {\n            newState.shift();\n          }\n          return newState;\n        });\n        return false;\n      }, lexical.COMMAND_PRIORITY_HIGH));\n    }\n    return () => unregisterCommandListeners.forEach(unregister => unregister());\n  }, [editor]);\n  return React.useMemo(() => loggedCommands, [loggedCommands]);\n}\nfunction printRangeSelection(selection) {\n  let res = '';\n  const formatText = printFormatProperties(selection);\n  res += `: range ${formatText !== '' ? `{ ${formatText} }` : ''} ${selection.style !== '' ? `{ style: ${selection.style} } ` : ''}`;\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorOffset = anchor.offset;\n  const focusOffset = focus.offset;\n  res += `\\n  ├ anchor { key: ${anchor.key}, offset: ${anchorOffset === null ? 'null' : anchorOffset}, type: ${anchor.type} }`;\n  res += `\\n  └ focus { key: ${focus.key}, offset: ${focusOffset === null ? 'null' : focusOffset}, type: ${focus.type} }`;\n  return res;\n}\nfunction printNodeSelection(selection) {\n  if (!lexical.$isNodeSelection(selection)) return '';\n  return `: node\\n  └ [${Array.from(selection._nodes).join(', ')}]`;\n}\nfunction printGridSelection(selection) {\n  return `: grid\\n  └ { grid: ${selection.gridKey}, anchorCell: ${selection.anchor.key}, focusCell: ${selection.focus.key} }`;\n}\nfunction generateContent(editor, commandsLog, exportDOM) {\n  const editorState = editor.getEditorState();\n  const editorConfig = editor._config;\n  const compositionKey = editor._compositionKey;\n  const editable = editor._editable;\n  if (exportDOM) {\n    let htmlString = '';\n    editorState.read(() => {\n      htmlString = printPrettyHTML(html.$generateHtmlFromNodes(editor));\n    });\n    return htmlString;\n  }\n  let res = ' root\\n';\n  const selectionString = editorState.read(() => {\n    const selection = lexical.$getSelection();\n    visitTree(lexical.$getRoot(), (node, indent) => {\n      const nodeKey = node.getKey();\n      const nodeKeyDisplay = `(${nodeKey})`;\n      const typeDisplay = node.getType() || '';\n      const isSelected = node.isSelected();\n      const idsDisplay = mark.$isMarkNode(node) ? ` id: [ ${node.getIDs().join(', ')} ] ` : '';\n      res += `${isSelected ? SYMBOLS.selectedLine : ' '} ${indent.join(' ')} ${nodeKeyDisplay} ${typeDisplay} ${idsDisplay} ${printNode(node)}\\n`;\n      res += printSelectedCharsLine({\n        indent,\n        isSelected,\n        node,\n        nodeKeyDisplay,\n        selection,\n        typeDisplay\n      });\n    });\n    return selection === null ? ': null' : lexical.$isRangeSelection(selection) ? printRangeSelection(selection) : lexical.DEPRECATED_$isGridSelection(selection) ? printGridSelection(selection) : printNodeSelection(selection);\n  });\n  res += '\\n selection' + selectionString;\n  res += '\\n\\n commands:';\n  if (commandsLog.length) {\n    for (const {\n      type,\n      payload\n    } of commandsLog) {\n      res += `\\n  └ { type: ${type}, payload: ${payload instanceof Event ? payload.constructor.name : payload} }`;\n    }\n  } else {\n    res += '\\n  └ None dispatched.';\n  }\n  res += '\\n\\n editor:';\n  res += `\\n  └ namespace ${editorConfig.namespace}`;\n  if (compositionKey !== null) {\n    res += `\\n  └ compositionKey ${compositionKey}`;\n  }\n  res += `\\n  └ editable ${String(editable)}`;\n  return res;\n}\nfunction visitTree(currentNode, visitor, indent = []) {\n  const childNodes = currentNode.getChildren();\n  const childNodesLength = childNodes.length;\n  childNodes.forEach((childNode, i) => {\n    visitor(childNode, indent.concat(i === childNodesLength - 1 ? SYMBOLS.isLastChild : SYMBOLS.hasNextSibling));\n    if (lexical.$isElementNode(childNode)) {\n      visitTree(childNode, visitor, indent.concat(i === childNodesLength - 1 ? SYMBOLS.ancestorIsLastChild : SYMBOLS.ancestorHasNextSibling));\n    }\n  });\n}\nfunction normalize(text) {\n  return Object.entries(NON_SINGLE_WIDTH_CHARS_REPLACEMENT).reduce((acc, [key, value]) => acc.replace(new RegExp(key, 'g'), String(value)), text);\n}\n\n// TODO Pass via props to allow customizability\nfunction printNode(node) {\n  if (lexical.$isTextNode(node)) {\n    const text = node.getTextContent();\n    const title = text.length === 0 ? '(empty)' : `\"${normalize(text)}\"`;\n    const properties = printAllTextNodeProperties(node);\n    return [title, properties.length !== 0 ? `{ ${properties} }` : null].filter(Boolean).join(' ').trim();\n  } else if (link.$isLinkNode(node)) {\n    const link = node.getURL();\n    const title = link.length === 0 ? '(empty)' : `\"${normalize(link)}\"`;\n    const properties = printAllLinkNodeProperties(node);\n    return [title, properties.length !== 0 ? `{ ${properties} }` : null].filter(Boolean).join(' ').trim();\n  } else {\n    return '';\n  }\n}\nconst FORMAT_PREDICATES = [node => node.hasFormat('bold') && 'Bold', node => node.hasFormat('code') && 'Code', node => node.hasFormat('italic') && 'Italic', node => node.hasFormat('strikethrough') && 'Strikethrough', node => node.hasFormat('subscript') && 'Subscript', node => node.hasFormat('superscript') && 'Superscript', node => node.hasFormat('underline') && 'Underline'];\nconst DETAIL_PREDICATES = [node => node.isDirectionless() && 'Directionless', node => node.isUnmergeable() && 'Unmergeable'];\nconst MODE_PREDICATES = [node => node.isToken() && 'Token', node => node.isSegmented() && 'Segmented'];\nfunction printAllTextNodeProperties(node) {\n  return [printFormatProperties(node), printDetailProperties(node), printModeProperties(node)].filter(Boolean).join(', ');\n}\nfunction printAllLinkNodeProperties(node) {\n  return [printTargetProperties(node), printRelProperties(node), printTitleProperties(node)].filter(Boolean).join(', ');\n}\nfunction printDetailProperties(nodeOrSelection) {\n  let str = DETAIL_PREDICATES.map(predicate => predicate(nodeOrSelection)).filter(Boolean).join(', ').toLocaleLowerCase();\n  if (str !== '') {\n    str = 'detail: ' + str;\n  }\n  return str;\n}\nfunction printModeProperties(nodeOrSelection) {\n  let str = MODE_PREDICATES.map(predicate => predicate(nodeOrSelection)).filter(Boolean).join(', ').toLocaleLowerCase();\n  if (str !== '') {\n    str = 'mode: ' + str;\n  }\n  return str;\n}\nfunction printFormatProperties(nodeOrSelection) {\n  let str = FORMAT_PREDICATES.map(predicate => predicate(nodeOrSelection)).filter(Boolean).join(', ').toLocaleLowerCase();\n  if (str !== '') {\n    str = 'format: ' + str;\n  }\n  return str;\n}\nfunction printTargetProperties(node) {\n  let str = node.getTarget();\n  // TODO Fix nullish on LinkNode\n  if (str != null) {\n    str = 'target: ' + str;\n  }\n  return str;\n}\nfunction printRelProperties(node) {\n  let str = node.getRel();\n  // TODO Fix nullish on LinkNode\n  if (str != null) {\n    str = 'rel: ' + str;\n  }\n  return str;\n}\nfunction printTitleProperties(node) {\n  let str = node.getTitle();\n  // TODO Fix nullish on LinkNode\n  if (str != null) {\n    str = 'title: ' + str;\n  }\n  return str;\n}\nfunction printSelectedCharsLine({\n  indent,\n  isSelected,\n  node,\n  nodeKeyDisplay,\n  selection,\n  typeDisplay\n}) {\n  // No selection or node is not selected.\n  if (!lexical.$isTextNode(node) || !lexical.$isRangeSelection(selection) || !isSelected || lexical.$isElementNode(node)) {\n    return '';\n  }\n\n  // No selected characters.\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  if (node.getTextContent() === '' || anchor.getNode() === selection.focus.getNode() && anchor.offset === focus.offset) {\n    return '';\n  }\n  const [start, end] = $getSelectionStartEnd(node, selection);\n  if (start === end) {\n    return '';\n  }\n  const selectionLastIndent = indent[indent.length - 1] === SYMBOLS.hasNextSibling ? SYMBOLS.ancestorHasNextSibling : SYMBOLS.ancestorIsLastChild;\n  const indentionChars = [...indent.slice(0, indent.length - 1), selectionLastIndent];\n  const unselectedChars = Array(start + 1).fill(' ');\n  const selectedChars = Array(end - start).fill(SYMBOLS.selectedChar);\n  const paddingLength = typeDisplay.length + 3; // 2 for the spaces around + 1 for the double quote.\n\n  const nodePrintSpaces = Array(nodeKeyDisplay.length + paddingLength).fill(' ');\n  return [SYMBOLS.selectedLine, indentionChars.join(' '), [...nodePrintSpaces, ...unselectedChars, ...selectedChars].join('')].join(' ') + '\\n';\n}\nfunction printPrettyHTML(str) {\n  const div = document.createElement('div');\n  div.innerHTML = str.trim();\n  return prettifyHTML(div, 0).innerHTML;\n}\nfunction prettifyHTML(node, level) {\n  const indentBefore = new Array(level++ + 1).join('  ');\n  const indentAfter = new Array(level - 1).join('  ');\n  let textNode;\n  for (let i = 0; i < node.children.length; i++) {\n    textNode = document.createTextNode('\\n' + indentBefore);\n    node.insertBefore(textNode, node.children[i]);\n    prettifyHTML(node.children[i], level);\n    if (node.lastElementChild === node.children[i]) {\n      textNode = document.createTextNode('\\n' + indentAfter);\n      node.appendChild(textNode);\n    }\n  }\n  return node;\n}\nfunction $getSelectionStartEnd(node, selection) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const textContent = node.getTextContent();\n  const textLength = textContent.length;\n  let start = -1;\n  let end = -1;\n\n  // Only one node is being selected.\n  if (anchor.type === 'text' && focus.type === 'text') {\n    const anchorNode = anchor.getNode();\n    const focusNode = focus.getNode();\n    if (anchorNode === focusNode && node === anchorNode && anchor.offset !== focus.offset) {\n      [start, end] = anchor.offset < focus.offset ? [anchor.offset, focus.offset] : [focus.offset, anchor.offset];\n    } else if (node === anchorNode) {\n      [start, end] = anchorNode.isBefore(focusNode) ? [anchor.offset, textLength] : [0, anchor.offset];\n    } else if (node === focusNode) {\n      [start, end] = focusNode.isBefore(anchorNode) ? [focus.offset, textLength] : [0, focus.offset];\n    } else {\n      // Node is within selection but not the anchor nor focus.\n      [start, end] = [0, textLength];\n    }\n  }\n\n  // Account for non-single width characters.\n  const numNonSingleWidthCharBeforeSelection = (textContent.slice(0, start).match(NON_SINGLE_WIDTH_CHARS_REGEX) || []).length;\n  const numNonSingleWidthCharInSelection = (textContent.slice(start, end).match(NON_SINGLE_WIDTH_CHARS_REGEX) || []).length;\n  return [start + numNonSingleWidthCharBeforeSelection, end + numNonSingleWidthCharBeforeSelection + numNonSingleWidthCharInSelection];\n}\n\nexports.TreeView = TreeView;\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict'\nconst LexicalTreeView = process.env.NODE_ENV === 'development' ? require('./LexicalTreeView.dev.js') : require('./LexicalTreeView.prod.js')\nmodule.exports = LexicalTreeView;"],
  "mappings": "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",
  "names": ["link"]
}
