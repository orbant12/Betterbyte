import {
  require_LexicalSelection
} from "./chunk-26HJLANE.js";
import {
  require_Lexical
} from "./chunk-OOMKOIZE.js";
import {
  __commonJS
} from "./chunk-CEQRFMJQ.js";

// node_modules/@lexical/utils/LexicalUtils.dev.js
var require_LexicalUtils_dev = __commonJS({
  "node_modules/@lexical/utils/LexicalUtils.dev.js"(exports) {
    "use strict";
    var selection = require_LexicalSelection();
    var lexical = require_Lexical();
    function mergeRegister(...func) {
      return () => {
        func.forEach((f) => f());
      };
    }
    function px(value) {
      return `${value}px`;
    }
    var mutationObserverConfig = {
      attributes: true,
      characterData: true,
      childList: true,
      subtree: true
    };
    function positionNodeOnRange(editor, range, onReposition) {
      let rootDOMNode = null;
      let parentDOMNode = null;
      let observer = null;
      let lastNodes = [];
      const wrapperNode = document.createElement("div");
      function position() {
        if (!(rootDOMNode !== null)) {
          throw Error(`Unexpected null rootDOMNode`);
        }
        if (!(parentDOMNode !== null)) {
          throw Error(`Unexpected null parentDOMNode`);
        }
        const {
          left: rootLeft,
          top: rootTop
        } = rootDOMNode.getBoundingClientRect();
        const parentDOMNode_ = parentDOMNode;
        const rects = selection.createRectsFromDOMRange(editor, range);
        if (!wrapperNode.isConnected) {
          parentDOMNode_.append(wrapperNode);
        }
        let hasRepositioned = false;
        for (let i = 0; i < rects.length; i++) {
          const rect = rects[i];
          const rectNode = lastNodes[i] || document.createElement("div");
          const rectNodeStyle = rectNode.style;
          if (rectNodeStyle.position !== "absolute") {
            rectNodeStyle.position = "absolute";
            hasRepositioned = true;
          }
          const left = px(rect.left - rootLeft);
          if (rectNodeStyle.left !== left) {
            rectNodeStyle.left = left;
            hasRepositioned = true;
          }
          const top = px(rect.top - rootTop);
          if (rectNodeStyle.top !== top) {
            rectNode.style.top = top;
            hasRepositioned = true;
          }
          const width = px(rect.width);
          if (rectNodeStyle.width !== width) {
            rectNode.style.width = width;
            hasRepositioned = true;
          }
          const height = px(rect.height);
          if (rectNodeStyle.height !== height) {
            rectNode.style.height = height;
            hasRepositioned = true;
          }
          if (rectNode.parentNode !== wrapperNode) {
            wrapperNode.append(rectNode);
            hasRepositioned = true;
          }
          lastNodes[i] = rectNode;
        }
        while (lastNodes.length > rects.length) {
          lastNodes.pop();
        }
        if (hasRepositioned) {
          onReposition(lastNodes);
        }
      }
      function stop() {
        parentDOMNode = null;
        rootDOMNode = null;
        if (observer !== null) {
          observer.disconnect();
        }
        observer = null;
        wrapperNode.remove();
        for (const node of lastNodes) {
          node.remove();
        }
        lastNodes = [];
      }
      function restart() {
        const currentRootDOMNode = editor.getRootElement();
        if (currentRootDOMNode === null) {
          return stop();
        }
        const currentParentDOMNode = currentRootDOMNode.parentElement;
        if (!(currentParentDOMNode instanceof HTMLElement)) {
          return stop();
        }
        stop();
        rootDOMNode = currentRootDOMNode;
        parentDOMNode = currentParentDOMNode;
        observer = new MutationObserver((mutations) => {
          const nextRootDOMNode = editor.getRootElement();
          const nextParentDOMNode = nextRootDOMNode && nextRootDOMNode.parentElement;
          if (nextRootDOMNode !== rootDOMNode || nextParentDOMNode !== parentDOMNode) {
            return restart();
          }
          for (const mutation of mutations) {
            if (!wrapperNode.contains(mutation.target)) {
              return position();
            }
          }
        });
        observer.observe(currentParentDOMNode, mutationObserverConfig);
        position();
      }
      const removeRootListener = editor.registerRootListener(restart);
      return () => {
        removeRootListener();
        stop();
      };
    }
    function markSelection(editor, onReposition) {
      let previousAnchorNode = null;
      let previousAnchorOffset = null;
      let previousFocusNode = null;
      let previousFocusOffset = null;
      let removeRangeListener = () => {
      };
      function compute(editorState) {
        editorState.read(() => {
          const selection2 = lexical.$getSelection();
          if (!lexical.$isRangeSelection(selection2)) {
            previousAnchorNode = null;
            previousAnchorOffset = null;
            previousFocusNode = null;
            previousFocusOffset = null;
            removeRangeListener();
            removeRangeListener = () => {
            };
            return;
          }
          const {
            anchor,
            focus
          } = selection2;
          const currentAnchorNode = anchor.getNode();
          const currentAnchorNodeKey = currentAnchorNode.getKey();
          const currentAnchorOffset = anchor.offset;
          const currentFocusNode = focus.getNode();
          const currentFocusNodeKey = currentFocusNode.getKey();
          const currentFocusOffset = focus.offset;
          const currentAnchorNodeDOM = editor.getElementByKey(currentAnchorNodeKey);
          const currentFocusNodeDOM = editor.getElementByKey(currentFocusNodeKey);
          const differentAnchorDOM = previousAnchorNode === null || currentAnchorNodeDOM === null || currentAnchorOffset !== previousAnchorOffset || currentAnchorNodeKey !== previousAnchorNode.getKey() || currentAnchorNode !== previousAnchorNode && (!(previousAnchorNode instanceof lexical.TextNode) || currentAnchorNode.updateDOM(previousAnchorNode, currentAnchorNodeDOM, editor._config));
          const differentFocusDOM = previousFocusNode === null || currentFocusNodeDOM === null || currentFocusOffset !== previousFocusOffset || currentFocusNodeKey !== previousFocusNode.getKey() || currentFocusNode !== previousFocusNode && (!(previousFocusNode instanceof lexical.TextNode) || currentFocusNode.updateDOM(previousFocusNode, currentFocusNodeDOM, editor._config));
          if (differentAnchorDOM || differentFocusDOM) {
            const anchorHTMLElement = editor.getElementByKey(anchor.getNode().getKey());
            const focusHTMLElement = editor.getElementByKey(focus.getNode().getKey());
            if (anchorHTMLElement !== null && focusHTMLElement !== null && anchorHTMLElement.tagName === "SPAN" && focusHTMLElement.tagName === "SPAN") {
              const range = document.createRange();
              let firstHTMLElement;
              let firstOffset;
              let lastHTMLElement;
              let lastOffset;
              if (focus.isBefore(anchor)) {
                firstHTMLElement = focusHTMLElement;
                firstOffset = focus.offset;
                lastHTMLElement = anchorHTMLElement;
                lastOffset = anchor.offset;
              } else {
                firstHTMLElement = anchorHTMLElement;
                firstOffset = anchor.offset;
                lastHTMLElement = focusHTMLElement;
                lastOffset = focus.offset;
              }
              const firstTextNode = firstHTMLElement.firstChild;
              if (!(firstTextNode !== null)) {
                throw Error(`Expected text node to be first child of span`);
              }
              const lastTextNode = lastHTMLElement.firstChild;
              if (!(lastTextNode !== null)) {
                throw Error(`Expected text node to be first child of span`);
              }
              range.setStart(firstTextNode, firstOffset);
              range.setEnd(lastTextNode, lastOffset);
              removeRangeListener();
              removeRangeListener = positionNodeOnRange(editor, range, (domNodes) => {
                for (const domNode of domNodes) {
                  const domNodeStyle = domNode.style;
                  if (domNodeStyle.background !== "Highlight") {
                    domNodeStyle.background = "Highlight";
                  }
                  if (domNodeStyle.color !== "HighlightText") {
                    domNodeStyle.color = "HighlightText";
                  }
                  if (domNodeStyle.zIndex !== "-1") {
                    domNodeStyle.zIndex = "-1";
                  }
                  if (domNodeStyle.pointerEvents !== "none") {
                    domNodeStyle.pointerEvents = "none";
                  }
                  if (domNodeStyle.marginTop !== px(-1.5)) {
                    domNodeStyle.marginTop = px(-1.5);
                  }
                  if (domNodeStyle.paddingTop !== px(4)) {
                    domNodeStyle.paddingTop = px(4);
                  }
                  if (domNodeStyle.paddingBottom !== px(0)) {
                    domNodeStyle.paddingBottom = px(0);
                  }
                }
                if (onReposition !== void 0) {
                  onReposition(domNodes);
                }
              });
            }
          }
          previousAnchorNode = currentAnchorNode;
          previousAnchorOffset = currentAnchorOffset;
          previousFocusNode = currentFocusNode;
          previousFocusOffset = currentFocusOffset;
        });
      }
      compute(editor.getEditorState());
      return mergeRegister(editor.registerUpdateListener(({
        editorState
      }) => compute(editorState)), removeRangeListener, () => {
        removeRangeListener();
      });
    }
    function addClassNamesToElement(element, ...classNames) {
      classNames.forEach((className) => {
        if (typeof className === "string") {
          const classesToAdd = className.split(" ").filter((n) => n !== "");
          element.classList.add(...classesToAdd);
        }
      });
    }
    function removeClassNamesFromElement(element, ...classNames) {
      classNames.forEach((className) => {
        if (typeof className === "string") {
          element.classList.remove(...className.split(" "));
        }
      });
    }
    function isMimeType(file, acceptableMimeTypes) {
      for (const acceptableType of acceptableMimeTypes) {
        if (file.type.startsWith(acceptableType)) {
          return true;
        }
      }
      return false;
    }
    function mediaFileReader(files, acceptableMimeTypes) {
      const filesIterator = files[Symbol.iterator]();
      return new Promise((resolve, reject) => {
        const processed = [];
        const handleNextFile = () => {
          const {
            done,
            value: file
          } = filesIterator.next();
          if (done) {
            return resolve(processed);
          }
          const fileReader = new FileReader();
          fileReader.addEventListener("error", reject);
          fileReader.addEventListener("load", () => {
            const result = fileReader.result;
            if (typeof result === "string") {
              processed.push({
                file,
                result
              });
            }
            handleNextFile();
          });
          if (isMimeType(file, acceptableMimeTypes)) {
            fileReader.readAsDataURL(file);
          } else {
            handleNextFile();
          }
        };
        handleNextFile();
      });
    }
    function $dfs(startingNode, endingNode) {
      const nodes = [];
      const start = (startingNode || lexical.$getRoot()).getLatest();
      const end = endingNode || (lexical.$isElementNode(start) ? start.getLastDescendant() : start);
      let node = start;
      let depth = $getDepth(node);
      while (node !== null && !node.is(end)) {
        nodes.push({
          depth,
          node
        });
        if (lexical.$isElementNode(node) && node.getChildrenSize() > 0) {
          node = node.getFirstChild();
          depth++;
        } else {
          let sibling = null;
          while (sibling === null && node !== null) {
            sibling = node.getNextSibling();
            if (sibling === null) {
              node = node.getParent();
              depth--;
            } else {
              node = sibling;
            }
          }
        }
      }
      if (node !== null && node.is(end)) {
        nodes.push({
          depth,
          node
        });
      }
      return nodes;
    }
    function $getDepth(node) {
      let innerNode = node;
      let depth = 0;
      while ((innerNode = innerNode.getParent()) !== null) {
        depth++;
      }
      return depth;
    }
    function $getNearestNodeOfType(node, klass) {
      let parent = node;
      while (parent != null) {
        if (parent instanceof klass) {
          return parent;
        }
        parent = parent.getParent();
      }
      return null;
    }
    function $getNearestBlockElementAncestorOrThrow(startNode) {
      const blockNode = $findMatchingParent(startNode, (node) => lexical.$isElementNode(node) && !node.isInline());
      if (!lexical.$isElementNode(blockNode)) {
        {
          throw Error(`Expected node ${startNode.__key} to have closest block element node.`);
        }
      }
      return blockNode;
    }
    function $findMatchingParent(startingNode, findFn) {
      let curr = startingNode;
      while (curr !== lexical.$getRoot() && curr != null) {
        if (findFn(curr)) {
          return curr;
        }
        curr = curr.getParent();
      }
      return null;
    }
    function registerNestedElementResolver(editor, targetNode, cloneNode, handleOverlap) {
      const $isTargetNode = (node) => {
        return node instanceof targetNode;
      };
      const $findMatch = (node) => {
        const children = node.getChildren();
        for (let i = 0; i < children.length; i++) {
          const child = children[i];
          if ($isTargetNode(child)) {
            return null;
          }
        }
        let parentNode = node;
        let childNode = node;
        while (parentNode !== null) {
          childNode = parentNode;
          parentNode = parentNode.getParent();
          if ($isTargetNode(parentNode)) {
            return {
              child: childNode,
              parent: parentNode
            };
          }
        }
        return null;
      };
      const elementNodeTransform = (node) => {
        const match = $findMatch(node);
        if (match !== null) {
          const {
            child,
            parent
          } = match;
          if (child.is(node)) {
            handleOverlap(parent, node);
            const nextSiblings = child.getNextSiblings();
            const nextSiblingsLength = nextSiblings.length;
            parent.insertAfter(child);
            if (nextSiblingsLength !== 0) {
              const newParent = cloneNode(parent);
              child.insertAfter(newParent);
              for (let i = 0; i < nextSiblingsLength; i++) {
                newParent.append(nextSiblings[i]);
              }
            }
            if (!parent.canBeEmpty() && parent.getChildrenSize() === 0) {
              parent.remove();
            }
          }
        }
      };
      return editor.registerNodeTransform(targetNode, elementNodeTransform);
    }
    function $restoreEditorState(editor, editorState) {
      const FULL_RECONCILE = 2;
      const nodeMap = /* @__PURE__ */ new Map();
      const activeEditorState = editor._pendingEditorState;
      for (const [key, node] of editorState._nodeMap) {
        const clone = selection.$cloneWithProperties(node);
        if (lexical.$isTextNode(clone)) {
          clone.__text = node.__text;
        }
        nodeMap.set(key, clone);
      }
      if (activeEditorState) {
        activeEditorState._nodeMap = nodeMap;
      }
      editor._dirtyType = FULL_RECONCILE;
      const selection$1 = editorState._selection;
      lexical.$setSelection(selection$1 === null ? null : selection$1.clone());
    }
    function $insertNodeToNearestRoot(node) {
      const selection2 = lexical.$getSelection() || lexical.$getPreviousSelection();
      if (lexical.$isRangeSelection(selection2)) {
        const {
          focus
        } = selection2;
        const focusNode = focus.getNode();
        const focusOffset = focus.offset;
        if (lexical.$isRootOrShadowRoot(focusNode)) {
          const focusChild = focusNode.getChildAtIndex(focusOffset);
          if (focusChild == null) {
            focusNode.append(node);
          } else {
            focusChild.insertBefore(node);
          }
          node.selectNext();
        } else {
          let splitNode;
          let splitOffset;
          if (lexical.$isTextNode(focusNode)) {
            splitNode = focusNode.getParentOrThrow();
            splitOffset = focusNode.getIndexWithinParent();
            if (focusOffset > 0) {
              splitOffset += 1;
              focusNode.splitText(focusOffset);
            }
          } else {
            splitNode = focusNode;
            splitOffset = focusOffset;
          }
          const [, rightTree] = lexical.$splitNode(splitNode, splitOffset);
          rightTree.insertBefore(node);
          rightTree.selectStart();
        }
      } else {
        if (selection2 != null) {
          const nodes = selection2.getNodes();
          nodes[nodes.length - 1].getTopLevelElementOrThrow().insertAfter(node);
        } else {
          const root = lexical.$getRoot();
          root.append(node);
        }
        const paragraphNode = lexical.$createParagraphNode();
        node.insertAfter(paragraphNode);
        paragraphNode.select();
      }
      return node.getLatest();
    }
    function $wrapNodeInElement(node, createElementNode) {
      const elementNode = createElementNode();
      node.replace(elementNode);
      elementNode.append(node);
      return elementNode;
    }
    function objectKlassEquals(object, objectClass) {
      return object !== null ? Object.getPrototypeOf(object).constructor.name === objectClass.name : false;
    }
    function $filter(nodes, filterFn) {
      const result = [];
      for (let i = 0; i < nodes.length; i++) {
        const node = filterFn(nodes[i]);
        if (node !== null) {
          result.push(node);
        }
      }
      return result;
    }
    function $insertFirst(parent, node) {
      const firstChild = parent.getFirstChild();
      if (firstChild !== null) {
        firstChild.insertBefore(node);
      } else {
        parent.append(node);
      }
    }
    exports.$splitNode = lexical.$splitNode;
    exports.isHTMLAnchorElement = lexical.isHTMLAnchorElement;
    exports.isHTMLElement = lexical.isHTMLElement;
    exports.$dfs = $dfs;
    exports.$filter = $filter;
    exports.$findMatchingParent = $findMatchingParent;
    exports.$getNearestBlockElementAncestorOrThrow = $getNearestBlockElementAncestorOrThrow;
    exports.$getNearestNodeOfType = $getNearestNodeOfType;
    exports.$insertFirst = $insertFirst;
    exports.$insertNodeToNearestRoot = $insertNodeToNearestRoot;
    exports.$restoreEditorState = $restoreEditorState;
    exports.$wrapNodeInElement = $wrapNodeInElement;
    exports.addClassNamesToElement = addClassNamesToElement;
    exports.isMimeType = isMimeType;
    exports.markSelection = markSelection;
    exports.mediaFileReader = mediaFileReader;
    exports.mergeRegister = mergeRegister;
    exports.objectKlassEquals = objectKlassEquals;
    exports.positionNodeOnRange = positionNodeOnRange;
    exports.registerNestedElementResolver = registerNestedElementResolver;
    exports.removeClassNamesFromElement = removeClassNamesFromElement;
  }
});

// node_modules/@lexical/utils/LexicalUtils.js
var require_LexicalUtils = __commonJS({
  "node_modules/@lexical/utils/LexicalUtils.js"(exports, module) {
    var LexicalUtils = true ? require_LexicalUtils_dev() : null;
    module.exports = LexicalUtils;
  }
});

export {
  require_LexicalUtils
};
//# sourceMappingURL=chunk-DBG3QTGS.js.map
