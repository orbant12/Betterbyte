{
  "version": 3,
  "sources": ["../../@lexical/react/LexicalAutoLinkPlugin.dev.js", "../../@lexical/react/LexicalAutoLinkPlugin.js"],
  "sourcesContent": ["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar link = require('@lexical/link');\nvar LexicalComposerContext = require('@lexical/react/LexicalComposerContext');\nvar utils = require('@lexical/utils');\nvar lexical = require('lexical');\nvar react = require('react');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction createLinkMatcherWithRegExp(regExp, urlTransformer = text => text) {\n  return text => {\n    const match = regExp.exec(text);\n    if (match === null) return null;\n    return {\n      index: match.index,\n      length: match[0].length,\n      text: match[0],\n      url: urlTransformer(match[0])\n    };\n  };\n}\nfunction findFirstMatch(text, matchers) {\n  for (let i = 0; i < matchers.length; i++) {\n    const match = matchers[i](text);\n    if (match) {\n      return match;\n    }\n  }\n  return null;\n}\nconst PUNCTUATION_OR_SPACE = /[.,;\\s]/;\nfunction isSeparator(char) {\n  return PUNCTUATION_OR_SPACE.test(char);\n}\nfunction endsWithSeparator(textContent) {\n  return isSeparator(textContent[textContent.length - 1]);\n}\nfunction startsWithSeparator(textContent) {\n  return isSeparator(textContent[0]);\n}\nfunction isPreviousNodeValid(node) {\n  let previousNode = node.getPreviousSibling();\n  if (lexical.$isElementNode(previousNode)) {\n    previousNode = previousNode.getLastDescendant();\n  }\n  return previousNode === null || lexical.$isLineBreakNode(previousNode) || lexical.$isTextNode(previousNode) && endsWithSeparator(previousNode.getTextContent());\n}\nfunction isNextNodeValid(node) {\n  let nextNode = node.getNextSibling();\n  if (lexical.$isElementNode(nextNode)) {\n    nextNode = nextNode.getFirstDescendant();\n  }\n  return nextNode === null || lexical.$isLineBreakNode(nextNode) || lexical.$isTextNode(nextNode) && startsWithSeparator(nextNode.getTextContent());\n}\nfunction isContentAroundIsValid(matchStart, matchEnd, text, nodes) {\n  const contentBeforeIsValid = matchStart > 0 ? isSeparator(text[matchStart - 1]) : isPreviousNodeValid(nodes[0]);\n  if (!contentBeforeIsValid) {\n    return false;\n  }\n  const contentAfterIsValid = matchEnd < text.length ? isSeparator(text[matchEnd]) : isNextNodeValid(nodes[nodes.length - 1]);\n  return contentAfterIsValid;\n}\nfunction extractMatchingNodes(nodes, startIndex, endIndex) {\n  const unmodifiedBeforeNodes = [];\n  const matchingNodes = [];\n  const unmodifiedAfterNodes = [];\n  let matchingOffset = 0;\n  let currentOffset = 0;\n  const currentNodes = [...nodes];\n  while (currentNodes.length > 0) {\n    const currentNode = currentNodes[0];\n    const currentNodeText = currentNode.getTextContent();\n    const currentNodeLength = currentNodeText.length;\n    const currentNodeStart = currentOffset;\n    const currentNodeEnd = currentOffset + currentNodeLength;\n    if (currentNodeEnd <= startIndex) {\n      unmodifiedBeforeNodes.push(currentNode);\n      matchingOffset += currentNodeLength;\n    } else if (currentNodeStart >= endIndex) {\n      unmodifiedAfterNodes.push(currentNode);\n    } else {\n      matchingNodes.push(currentNode);\n    }\n    currentOffset += currentNodeLength;\n    currentNodes.shift();\n  }\n  return [matchingOffset, unmodifiedBeforeNodes, matchingNodes, unmodifiedAfterNodes];\n}\nfunction createAutoLinkNode(nodes, startIndex, endIndex, match) {\n  const linkNode = link.$createAutoLinkNode(match.url, match.attributes);\n  if (nodes.length === 1) {\n    let remainingTextNode = nodes[0];\n    let linkTextNode;\n    if (startIndex === 0) {\n      [linkTextNode, remainingTextNode] = remainingTextNode.splitText(endIndex);\n    } else {\n      [, linkTextNode, remainingTextNode] = remainingTextNode.splitText(startIndex, endIndex);\n    }\n    const textNode = lexical.$createTextNode(match.text);\n    textNode.setFormat(linkTextNode.getFormat());\n    textNode.setDetail(linkTextNode.getDetail());\n    linkNode.append(textNode);\n    linkTextNode.replace(linkNode);\n    return remainingTextNode;\n  } else if (nodes.length > 1) {\n    const firstTextNode = nodes[0];\n    let offset = firstTextNode.getTextContent().length;\n    let firstLinkTextNode;\n    if (startIndex === 0) {\n      firstLinkTextNode = firstTextNode;\n    } else {\n      [, firstLinkTextNode] = firstTextNode.splitText(startIndex);\n    }\n    const linkNodes = [];\n    let remainingTextNode;\n    for (let i = 1; i < nodes.length; i++) {\n      const currentNode = nodes[i];\n      const currentNodeText = currentNode.getTextContent();\n      const currentNodeLength = currentNodeText.length;\n      const currentNodeStart = offset;\n      const currentNodeEnd = offset + currentNodeLength;\n      if (currentNodeStart < endIndex) {\n        if (currentNodeEnd <= endIndex) {\n          linkNodes.push(currentNode);\n        } else {\n          const [linkTextNode, endNode] = currentNode.splitText(endIndex - currentNodeStart);\n          linkNodes.push(linkTextNode);\n          remainingTextNode = endNode;\n        }\n      }\n      offset += currentNodeLength;\n    }\n    const selection = lexical.$getSelection();\n    const selectedTextNode = selection ? selection.getNodes().find(lexical.$isTextNode) : undefined;\n    const textNode = lexical.$createTextNode(firstLinkTextNode.getTextContent());\n    textNode.setFormat(firstLinkTextNode.getFormat());\n    textNode.setDetail(firstLinkTextNode.getDetail());\n    linkNode.append(textNode, ...linkNodes);\n    // it does not preserve caret position if caret was at the first text node\n    // so we need to restore caret position\n    if (selectedTextNode && selectedTextNode === firstLinkTextNode) {\n      if (lexical.$isRangeSelection(selection)) {\n        textNode.select(selection.anchor.offset, selection.focus.offset);\n      } else if (lexical.$isNodeSelection(selection)) {\n        textNode.select(0, textNode.getTextContent().length);\n      }\n    }\n    firstLinkTextNode.replace(linkNode);\n    return remainingTextNode;\n  }\n  return undefined;\n}\nfunction handleLinkCreation(nodes, matchers, onChange) {\n  let currentNodes = [...nodes];\n  let text = currentNodes.map(node => node.getTextContent()).join('');\n  let match;\n  let invalidMatchEnd = 0;\n  while ((match = findFirstMatch(text, matchers)) && match !== null) {\n    const matchStart = match.index;\n    const matchLength = match.length;\n    const matchEnd = matchStart + matchLength;\n    const isValid = isContentAroundIsValid(invalidMatchEnd + matchStart, invalidMatchEnd + matchEnd, text, currentNodes);\n    if (isValid) {\n      const [matchingOffset,, matchingNodes, unmodifiedAfterNodes] = extractMatchingNodes(currentNodes, invalidMatchEnd + matchStart, invalidMatchEnd + matchEnd);\n      const actualMatchStart = invalidMatchEnd + matchStart - matchingOffset;\n      const actualMatchEnd = invalidMatchEnd + matchEnd - matchingOffset;\n      const remainingTextNode = createAutoLinkNode(matchingNodes, actualMatchStart, actualMatchEnd, match);\n      currentNodes = remainingTextNode ? [remainingTextNode, ...unmodifiedAfterNodes] : unmodifiedAfterNodes;\n      onChange(match.url, null);\n      invalidMatchEnd = 0;\n    } else {\n      invalidMatchEnd += matchEnd;\n    }\n    text = text.substring(matchEnd);\n  }\n}\nfunction handleLinkEdit(linkNode, matchers, onChange) {\n  // Check children are simple text\n  const children = linkNode.getChildren();\n  const childrenLength = children.length;\n  for (let i = 0; i < childrenLength; i++) {\n    const child = children[i];\n    if (!lexical.$isTextNode(child) || !child.isSimpleText()) {\n      replaceWithChildren(linkNode);\n      onChange(null, linkNode.getURL());\n      return;\n    }\n  }\n\n  // Check text content fully matches\n  const text = linkNode.getTextContent();\n  const match = findFirstMatch(text, matchers);\n  if (match === null || match.text !== text) {\n    replaceWithChildren(linkNode);\n    onChange(null, linkNode.getURL());\n    return;\n  }\n\n  // Check neighbors\n  if (!isPreviousNodeValid(linkNode) || !isNextNodeValid(linkNode)) {\n    replaceWithChildren(linkNode);\n    onChange(null, linkNode.getURL());\n    return;\n  }\n  const url = linkNode.getURL();\n  if (url !== match.url) {\n    linkNode.setURL(match.url);\n    onChange(match.url, url);\n  }\n  if (match.attributes) {\n    const rel = linkNode.getRel();\n    if (rel !== match.attributes.rel) {\n      linkNode.setRel(match.attributes.rel || null);\n      onChange(match.attributes.rel || null, rel);\n    }\n    const target = linkNode.getTarget();\n    if (target !== match.attributes.target) {\n      linkNode.setTarget(match.attributes.target || null);\n      onChange(match.attributes.target || null, target);\n    }\n  }\n}\n\n// Bad neighbors are edits in neighbor nodes that make AutoLinks incompatible.\n// Given the creation preconditions, these can only be simple text nodes.\nfunction handleBadNeighbors(textNode, matchers, onChange) {\n  const previousSibling = textNode.getPreviousSibling();\n  const nextSibling = textNode.getNextSibling();\n  const text = textNode.getTextContent();\n  if (link.$isAutoLinkNode(previousSibling) && !startsWithSeparator(text)) {\n    previousSibling.append(textNode);\n    handleLinkEdit(previousSibling, matchers, onChange);\n    onChange(null, previousSibling.getURL());\n  }\n  if (link.$isAutoLinkNode(nextSibling) && !endsWithSeparator(text)) {\n    replaceWithChildren(nextSibling);\n    handleLinkEdit(nextSibling, matchers, onChange);\n    onChange(null, nextSibling.getURL());\n  }\n}\nfunction replaceWithChildren(node) {\n  const children = node.getChildren();\n  const childrenLength = children.length;\n  for (let j = childrenLength - 1; j >= 0; j--) {\n    node.insertAfter(children[j]);\n  }\n  node.remove();\n  return children.map(child => child.getLatest());\n}\nfunction getTextNodesToMatch(textNode) {\n  // check if next siblings are simple text nodes till a node contains a space separator\n  const textNodesToMatch = [textNode];\n  let nextSibling = textNode.getNextSibling();\n  while (nextSibling !== null && lexical.$isTextNode(nextSibling) && nextSibling.isSimpleText()) {\n    textNodesToMatch.push(nextSibling);\n    if (/[\\s]/.test(nextSibling.getTextContent())) {\n      break;\n    }\n    nextSibling = nextSibling.getNextSibling();\n  }\n  return textNodesToMatch;\n}\nfunction useAutoLink(editor, matchers, onChange) {\n  react.useEffect(() => {\n    if (!editor.hasNodes([link.AutoLinkNode])) {\n      {\n        throw Error(`LexicalAutoLinkPlugin: AutoLinkNode not registered on editor`);\n      }\n    }\n    const onChangeWrapped = (url, prevUrl) => {\n      if (onChange) {\n        onChange(url, prevUrl);\n      }\n    };\n    return utils.mergeRegister(editor.registerNodeTransform(lexical.TextNode, textNode => {\n      const parent = textNode.getParentOrThrow();\n      const previous = textNode.getPreviousSibling();\n      if (link.$isAutoLinkNode(parent)) {\n        handleLinkEdit(parent, matchers, onChangeWrapped);\n      } else if (!link.$isLinkNode(parent)) {\n        if (textNode.isSimpleText() && (startsWithSeparator(textNode.getTextContent()) || !link.$isAutoLinkNode(previous))) {\n          const textNodesToMatch = getTextNodesToMatch(textNode);\n          handleLinkCreation(textNodesToMatch, matchers, onChangeWrapped);\n        }\n        handleBadNeighbors(textNode, matchers, onChangeWrapped);\n      }\n    }));\n  }, [editor, matchers, onChange]);\n}\nfunction AutoLinkPlugin({\n  matchers,\n  onChange\n}) {\n  const [editor] = LexicalComposerContext.useLexicalComposerContext();\n  useAutoLink(editor, matchers, onChange);\n  return null;\n}\n\nexports.AutoLinkPlugin = AutoLinkPlugin;\nexports.createLinkMatcherWithRegExp = createLinkMatcherWithRegExp;\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict'\nconst LexicalAutoLinkPlugin = process.env.NODE_ENV === 'development' ? require('./LexicalAutoLinkPlugin.dev.js') : require('./LexicalAutoLinkPlugin.prod.js')\nmodule.exports = LexicalAutoLinkPlugin;"],
  "mappings": "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",
  "names": []
}
