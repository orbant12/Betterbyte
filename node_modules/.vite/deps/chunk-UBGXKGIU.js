import {
  require_LexicalUtils
} from "./chunk-DBG3QTGS.js";
import {
  require_LexicalSelection
} from "./chunk-26HJLANE.js";
import {
  require_Lexical
} from "./chunk-OOMKOIZE.js";
import {
  __commonJS
} from "./chunk-CEQRFMJQ.js";

// node_modules/@lexical/html/LexicalHtml.dev.js
var require_LexicalHtml_dev = __commonJS({
  "node_modules/@lexical/html/LexicalHtml.dev.js"(exports) {
    "use strict";
    var selection = require_LexicalSelection();
    var utils = require_LexicalUtils();
    var lexical = require_Lexical();
    function $generateNodesFromDOM(editor, dom) {
      const elements = dom.body ? dom.body.childNodes : [];
      let lexicalNodes = [];
      for (let i = 0; i < elements.length; i++) {
        const element = elements[i];
        if (!IGNORE_TAGS.has(element.nodeName)) {
          const lexicalNode = $createNodesFromDOM(element, editor);
          if (lexicalNode !== null) {
            lexicalNodes = lexicalNodes.concat(lexicalNode);
          }
        }
      }
      return lexicalNodes;
    }
    function $generateHtmlFromNodes(editor, selection2) {
      if (typeof document === "undefined" || typeof window === "undefined") {
        throw new Error("To use $generateHtmlFromNodes in headless mode please initialize a headless browser implementation such as JSDom before calling this function.");
      }
      const container = document.createElement("div");
      const root = lexical.$getRoot();
      const topLevelChildren = root.getChildren();
      for (let i = 0; i < topLevelChildren.length; i++) {
        const topLevelNode = topLevelChildren[i];
        $appendNodesToHTML(editor, topLevelNode, container, selection2);
      }
      return container.innerHTML;
    }
    function $appendNodesToHTML(editor, currentNode, parentElement, selection$1 = null) {
      let shouldInclude = selection$1 != null ? currentNode.isSelected(selection$1) : true;
      const shouldExclude = lexical.$isElementNode(currentNode) && currentNode.excludeFromCopy("html");
      let target = currentNode;
      if (selection$1 !== null) {
        let clone = selection.$cloneWithProperties(currentNode);
        clone = lexical.$isTextNode(clone) && selection$1 != null ? selection.$sliceSelectedTextNodeContent(selection$1, clone) : clone;
        target = clone;
      }
      const children = lexical.$isElementNode(target) ? target.getChildren() : [];
      const registeredNode = editor._nodes.get(target.getType());
      let exportOutput;
      if (registeredNode && registeredNode.exportDOM !== void 0) {
        exportOutput = registeredNode.exportDOM(editor, target);
      } else {
        exportOutput = target.exportDOM(editor);
      }
      const {
        element,
        after
      } = exportOutput;
      if (!element) {
        return false;
      }
      const fragment = document.createDocumentFragment();
      for (let i = 0; i < children.length; i++) {
        const childNode = children[i];
        const shouldIncludeChild = $appendNodesToHTML(editor, childNode, fragment, selection$1);
        if (!shouldInclude && lexical.$isElementNode(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection$1, "html")) {
          shouldInclude = true;
        }
      }
      if (shouldInclude && !shouldExclude) {
        if (utils.isHTMLElement(element)) {
          element.append(fragment);
        }
        parentElement.append(element);
        if (after) {
          const newElement = after.call(target, element);
          if (newElement)
            element.replaceWith(newElement);
        }
      } else {
        parentElement.append(fragment);
      }
      return shouldInclude;
    }
    function getConversionFunction(domNode, editor) {
      const {
        nodeName
      } = domNode;
      const cachedConversions = editor._htmlConversions.get(nodeName.toLowerCase());
      let currentConversion = null;
      if (cachedConversions !== void 0) {
        for (const cachedConversion of cachedConversions) {
          const domConversion = cachedConversion(domNode);
          if (domConversion !== null && (currentConversion === null || currentConversion.priority < domConversion.priority)) {
            currentConversion = domConversion;
          }
        }
      }
      return currentConversion !== null ? currentConversion.conversion : null;
    }
    var IGNORE_TAGS = /* @__PURE__ */ new Set(["STYLE", "SCRIPT"]);
    function $createNodesFromDOM(node, editor, forChildMap = /* @__PURE__ */ new Map(), parentLexicalNode) {
      let lexicalNodes = [];
      if (IGNORE_TAGS.has(node.nodeName)) {
        return lexicalNodes;
      }
      let currentLexicalNode = null;
      const transformFunction = getConversionFunction(node, editor);
      const transformOutput = transformFunction ? transformFunction(node) : null;
      let postTransform = null;
      if (transformOutput !== null) {
        postTransform = transformOutput.after;
        const transformNodes = transformOutput.node;
        currentLexicalNode = Array.isArray(transformNodes) ? transformNodes[transformNodes.length - 1] : transformNodes;
        if (currentLexicalNode !== null) {
          for (const [, forChildFunction] of forChildMap) {
            currentLexicalNode = forChildFunction(currentLexicalNode, parentLexicalNode);
            if (!currentLexicalNode) {
              break;
            }
          }
          if (currentLexicalNode) {
            lexicalNodes.push(...Array.isArray(transformNodes) ? transformNodes : [currentLexicalNode]);
          }
        }
        if (transformOutput.forChild != null) {
          forChildMap.set(node.nodeName, transformOutput.forChild);
        }
      }
      const children = node.childNodes;
      let childLexicalNodes = [];
      for (let i = 0; i < children.length; i++) {
        childLexicalNodes.push(...$createNodesFromDOM(children[i], editor, new Map(forChildMap), currentLexicalNode));
      }
      if (postTransform != null) {
        childLexicalNodes = postTransform(childLexicalNodes);
      }
      if (currentLexicalNode == null) {
        lexicalNodes = lexicalNodes.concat(childLexicalNodes);
      } else {
        if (lexical.$isElementNode(currentLexicalNode)) {
          currentLexicalNode.append(...childLexicalNodes);
        }
      }
      return lexicalNodes;
    }
    exports.$generateHtmlFromNodes = $generateHtmlFromNodes;
    exports.$generateNodesFromDOM = $generateNodesFromDOM;
  }
});

// node_modules/@lexical/html/LexicalHtml.js
var require_LexicalHtml = __commonJS({
  "node_modules/@lexical/html/LexicalHtml.js"(exports, module) {
    "use strict";
    var LexicalHtml = true ? require_LexicalHtml_dev() : null;
    module.exports = LexicalHtml;
  }
});

export {
  require_LexicalHtml
};
//# sourceMappingURL=chunk-UBGXKGIU.js.map
