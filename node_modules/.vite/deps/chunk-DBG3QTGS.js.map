{
  "version": 3,
  "sources": ["../../@lexical/utils/LexicalUtils.dev.js", "../../@lexical/utils/LexicalUtils.js"],
  "sourcesContent": ["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar selection = require('@lexical/selection');\nvar lexical = require('lexical');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Returns a function that will execute all functions passed when called. It is generally used\n * to register multiple lexical listeners and then tear them down with a single function call, such\n * as React's useEffect hook.\n * @example\n * ```ts\n * useEffect(() => {\n *   return mergeRegister(\n *     editor.registerCommand(...registerCommand1 logic),\n *     editor.registerCommand(...registerCommand2 logic),\n *     editor.registerCommand(...registerCommand3 logic)\n *   )\n * }, [editor])\n * ```\n * In this case, useEffect is returning the function returned by mergeRegister as a cleanup\n * function to be executed after either the useEffect runs again (due to one of its dependencies\n * updating) or the component it resides in unmounts.\n * Note the functions don't neccesarily need to be in an array as all arguements\n * are considered to be the func argument and spread from there.\n * @param func - An array of functions meant to be executed by the returned function.\n * @returns the function which executes all the passed register command functions.\n */\nfunction mergeRegister(...func) {\n  return () => {\n    func.forEach(f => f());\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction px(value) {\n  return `${value}px`;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst mutationObserverConfig = {\n  attributes: true,\n  characterData: true,\n  childList: true,\n  subtree: true\n};\nfunction positionNodeOnRange(editor, range, onReposition) {\n  let rootDOMNode = null;\n  let parentDOMNode = null;\n  let observer = null;\n  let lastNodes = [];\n  const wrapperNode = document.createElement('div');\n  function position() {\n    if (!(rootDOMNode !== null)) {\n      throw Error(`Unexpected null rootDOMNode`);\n    }\n    if (!(parentDOMNode !== null)) {\n      throw Error(`Unexpected null parentDOMNode`);\n    }\n    const {\n      left: rootLeft,\n      top: rootTop\n    } = rootDOMNode.getBoundingClientRect();\n    const parentDOMNode_ = parentDOMNode;\n    const rects = selection.createRectsFromDOMRange(editor, range);\n    if (!wrapperNode.isConnected) {\n      parentDOMNode_.append(wrapperNode);\n    }\n    let hasRepositioned = false;\n    for (let i = 0; i < rects.length; i++) {\n      const rect = rects[i];\n      // Try to reuse the previously created Node when possible, no need to\n      // remove/create on the most common case reposition case\n      const rectNode = lastNodes[i] || document.createElement('div');\n      const rectNodeStyle = rectNode.style;\n      if (rectNodeStyle.position !== 'absolute') {\n        rectNodeStyle.position = 'absolute';\n        hasRepositioned = true;\n      }\n      const left = px(rect.left - rootLeft);\n      if (rectNodeStyle.left !== left) {\n        rectNodeStyle.left = left;\n        hasRepositioned = true;\n      }\n      const top = px(rect.top - rootTop);\n      if (rectNodeStyle.top !== top) {\n        rectNode.style.top = top;\n        hasRepositioned = true;\n      }\n      const width = px(rect.width);\n      if (rectNodeStyle.width !== width) {\n        rectNode.style.width = width;\n        hasRepositioned = true;\n      }\n      const height = px(rect.height);\n      if (rectNodeStyle.height !== height) {\n        rectNode.style.height = height;\n        hasRepositioned = true;\n      }\n      if (rectNode.parentNode !== wrapperNode) {\n        wrapperNode.append(rectNode);\n        hasRepositioned = true;\n      }\n      lastNodes[i] = rectNode;\n    }\n    while (lastNodes.length > rects.length) {\n      lastNodes.pop();\n    }\n    if (hasRepositioned) {\n      onReposition(lastNodes);\n    }\n  }\n  function stop() {\n    parentDOMNode = null;\n    rootDOMNode = null;\n    if (observer !== null) {\n      observer.disconnect();\n    }\n    observer = null;\n    wrapperNode.remove();\n    for (const node of lastNodes) {\n      node.remove();\n    }\n    lastNodes = [];\n  }\n  function restart() {\n    const currentRootDOMNode = editor.getRootElement();\n    if (currentRootDOMNode === null) {\n      return stop();\n    }\n    const currentParentDOMNode = currentRootDOMNode.parentElement;\n    if (!(currentParentDOMNode instanceof HTMLElement)) {\n      return stop();\n    }\n    stop();\n    rootDOMNode = currentRootDOMNode;\n    parentDOMNode = currentParentDOMNode;\n    observer = new MutationObserver(mutations => {\n      const nextRootDOMNode = editor.getRootElement();\n      const nextParentDOMNode = nextRootDOMNode && nextRootDOMNode.parentElement;\n      if (nextRootDOMNode !== rootDOMNode || nextParentDOMNode !== parentDOMNode) {\n        return restart();\n      }\n      for (const mutation of mutations) {\n        if (!wrapperNode.contains(mutation.target)) {\n          // TODO throttle\n          return position();\n        }\n      }\n    });\n    observer.observe(currentParentDOMNode, mutationObserverConfig);\n    position();\n  }\n  const removeRootListener = editor.registerRootListener(restart);\n  return () => {\n    removeRootListener();\n    stop();\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction markSelection(editor, onReposition) {\n  let previousAnchorNode = null;\n  let previousAnchorOffset = null;\n  let previousFocusNode = null;\n  let previousFocusOffset = null;\n  let removeRangeListener = () => {};\n  function compute(editorState) {\n    editorState.read(() => {\n      const selection = lexical.$getSelection();\n      if (!lexical.$isRangeSelection(selection)) {\n        // TODO\n        previousAnchorNode = null;\n        previousAnchorOffset = null;\n        previousFocusNode = null;\n        previousFocusOffset = null;\n        removeRangeListener();\n        removeRangeListener = () => {};\n        return;\n      }\n      const {\n        anchor,\n        focus\n      } = selection;\n      const currentAnchorNode = anchor.getNode();\n      const currentAnchorNodeKey = currentAnchorNode.getKey();\n      const currentAnchorOffset = anchor.offset;\n      const currentFocusNode = focus.getNode();\n      const currentFocusNodeKey = currentFocusNode.getKey();\n      const currentFocusOffset = focus.offset;\n      const currentAnchorNodeDOM = editor.getElementByKey(currentAnchorNodeKey);\n      const currentFocusNodeDOM = editor.getElementByKey(currentFocusNodeKey);\n      const differentAnchorDOM = previousAnchorNode === null || currentAnchorNodeDOM === null || currentAnchorOffset !== previousAnchorOffset || currentAnchorNodeKey !== previousAnchorNode.getKey() || currentAnchorNode !== previousAnchorNode && (!(previousAnchorNode instanceof lexical.TextNode) || currentAnchorNode.updateDOM(previousAnchorNode, currentAnchorNodeDOM, editor._config));\n      const differentFocusDOM = previousFocusNode === null || currentFocusNodeDOM === null || currentFocusOffset !== previousFocusOffset || currentFocusNodeKey !== previousFocusNode.getKey() || currentFocusNode !== previousFocusNode && (!(previousFocusNode instanceof lexical.TextNode) || currentFocusNode.updateDOM(previousFocusNode, currentFocusNodeDOM, editor._config));\n      if (differentAnchorDOM || differentFocusDOM) {\n        const anchorHTMLElement = editor.getElementByKey(anchor.getNode().getKey());\n        const focusHTMLElement = editor.getElementByKey(focus.getNode().getKey());\n        // TODO handle selection beyond the common TextNode\n        if (anchorHTMLElement !== null && focusHTMLElement !== null && anchorHTMLElement.tagName === 'SPAN' && focusHTMLElement.tagName === 'SPAN') {\n          const range = document.createRange();\n          let firstHTMLElement;\n          let firstOffset;\n          let lastHTMLElement;\n          let lastOffset;\n          if (focus.isBefore(anchor)) {\n            firstHTMLElement = focusHTMLElement;\n            firstOffset = focus.offset;\n            lastHTMLElement = anchorHTMLElement;\n            lastOffset = anchor.offset;\n          } else {\n            firstHTMLElement = anchorHTMLElement;\n            firstOffset = anchor.offset;\n            lastHTMLElement = focusHTMLElement;\n            lastOffset = focus.offset;\n          }\n          const firstTextNode = firstHTMLElement.firstChild;\n          if (!(firstTextNode !== null)) {\n            throw Error(`Expected text node to be first child of span`);\n          }\n          const lastTextNode = lastHTMLElement.firstChild;\n          if (!(lastTextNode !== null)) {\n            throw Error(`Expected text node to be first child of span`);\n          }\n          range.setStart(firstTextNode, firstOffset);\n          range.setEnd(lastTextNode, lastOffset);\n          removeRangeListener();\n          removeRangeListener = positionNodeOnRange(editor, range, domNodes => {\n            for (const domNode of domNodes) {\n              const domNodeStyle = domNode.style;\n              if (domNodeStyle.background !== 'Highlight') {\n                domNodeStyle.background = 'Highlight';\n              }\n              if (domNodeStyle.color !== 'HighlightText') {\n                domNodeStyle.color = 'HighlightText';\n              }\n              if (domNodeStyle.zIndex !== '-1') {\n                domNodeStyle.zIndex = '-1';\n              }\n              if (domNodeStyle.pointerEvents !== 'none') {\n                domNodeStyle.pointerEvents = 'none';\n              }\n              if (domNodeStyle.marginTop !== px(-1.5)) {\n                domNodeStyle.marginTop = px(-1.5);\n              }\n              if (domNodeStyle.paddingTop !== px(4)) {\n                domNodeStyle.paddingTop = px(4);\n              }\n              if (domNodeStyle.paddingBottom !== px(0)) {\n                domNodeStyle.paddingBottom = px(0);\n              }\n            }\n            if (onReposition !== undefined) {\n              onReposition(domNodes);\n            }\n          });\n        }\n      }\n      previousAnchorNode = currentAnchorNode;\n      previousAnchorOffset = currentAnchorOffset;\n      previousFocusNode = currentFocusNode;\n      previousFocusOffset = currentFocusOffset;\n    });\n  }\n  compute(editor.getEditorState());\n  return mergeRegister(editor.registerUpdateListener(({\n    editorState\n  }) => compute(editorState)), removeRangeListener, () => {\n    removeRangeListener();\n  });\n}\n\n/** @module @lexical/utils */\n/**\n * Takes an HTML element and adds the classNames passed within an array,\n * ignoring any non-string types. A space can be used to add multiple classes\n * eg. addClassNamesToElement(element, ['element-inner active', true, null])\n * will add both 'element-inner' and 'active' as classes to that element.\n * @param element - The element in which the classes are added\n * @param classNames - An array defining the class names to add to the element\n */\nfunction addClassNamesToElement(element, ...classNames) {\n  classNames.forEach(className => {\n    if (typeof className === 'string') {\n      const classesToAdd = className.split(' ').filter(n => n !== '');\n      element.classList.add(...classesToAdd);\n    }\n  });\n}\n\n/**\n * Takes an HTML element and removes the classNames passed within an array,\n * ignoring any non-string types. A space can be used to remove multiple classes\n * eg. removeClassNamesFromElement(element, ['active small', true, null])\n * will remove both the 'active' and 'small' classes from that element.\n * @param element - The element in which the classes are removed\n * @param classNames - An array defining the class names to remove from the element\n */\nfunction removeClassNamesFromElement(element, ...classNames) {\n  classNames.forEach(className => {\n    if (typeof className === 'string') {\n      element.classList.remove(...className.split(' '));\n    }\n  });\n}\n\n/**\n * Returns true if the file type matches the types passed within the acceptableMimeTypes array, false otherwise.\n * The types passed must be strings and are CASE-SENSITIVE.\n * eg. if file is of type 'text' and acceptableMimeTypes = ['TEXT', 'IMAGE'] the function will return false.\n * @param file - The file you want to type check.\n * @param acceptableMimeTypes - An array of strings of types which the file is checked against.\n * @returns true if the file is an acceptable mime type, false otherwise.\n */\nfunction isMimeType(file, acceptableMimeTypes) {\n  for (const acceptableType of acceptableMimeTypes) {\n    if (file.type.startsWith(acceptableType)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Lexical File Reader with:\n *  1. MIME type support\n *  2. batched results (HistoryPlugin compatibility)\n *  3. Order aware (respects the order when multiple Files are passed)\n *\n * const filesResult = await mediaFileReader(files, ['image/']);\n * filesResult.forEach(file => editor.dispatchCommand('INSERT_IMAGE', {\n *   src: file.result,\n * }));\n */\nfunction mediaFileReader(files, acceptableMimeTypes) {\n  const filesIterator = files[Symbol.iterator]();\n  return new Promise((resolve, reject) => {\n    const processed = [];\n    const handleNextFile = () => {\n      const {\n        done,\n        value: file\n      } = filesIterator.next();\n      if (done) {\n        return resolve(processed);\n      }\n      const fileReader = new FileReader();\n      fileReader.addEventListener('error', reject);\n      fileReader.addEventListener('load', () => {\n        const result = fileReader.result;\n        if (typeof result === 'string') {\n          processed.push({\n            file,\n            result\n          });\n        }\n        handleNextFile();\n      });\n      if (isMimeType(file, acceptableMimeTypes)) {\n        fileReader.readAsDataURL(file);\n      } else {\n        handleNextFile();\n      }\n    };\n    handleNextFile();\n  });\n}\n\n/**\n * \"Depth-First Search\" starts at the root/top node of a tree and goes as far as it can down a branch end\n * before backtracking and finding a new path. Consider solving a maze by hugging either wall, moving down a\n * branch until you hit a dead-end (leaf) and backtracking to find the nearest branching path and repeat.\n * It will then return all the nodes found in the search in an array of objects.\n * @param startingNode - The node to start the search, if ommitted, it will start at the root node.\n * @param endingNode - The node to end the search, if ommitted, it will find all descendants of the startingNode.\n * @returns An array of objects of all the nodes found by the search, including their depth into the tree.\n * {depth: number, node: LexicalNode} It will always return at least 1 node (the ending node) so long as it exists\n */\nfunction $dfs(startingNode, endingNode) {\n  const nodes = [];\n  const start = (startingNode || lexical.$getRoot()).getLatest();\n  const end = endingNode || (lexical.$isElementNode(start) ? start.getLastDescendant() : start);\n  let node = start;\n  let depth = $getDepth(node);\n  while (node !== null && !node.is(end)) {\n    nodes.push({\n      depth,\n      node\n    });\n    if (lexical.$isElementNode(node) && node.getChildrenSize() > 0) {\n      node = node.getFirstChild();\n      depth++;\n    } else {\n      // Find immediate sibling or nearest parent sibling\n      let sibling = null;\n      while (sibling === null && node !== null) {\n        sibling = node.getNextSibling();\n        if (sibling === null) {\n          node = node.getParent();\n          depth--;\n        } else {\n          node = sibling;\n        }\n      }\n    }\n  }\n  if (node !== null && node.is(end)) {\n    nodes.push({\n      depth,\n      node\n    });\n  }\n  return nodes;\n}\nfunction $getDepth(node) {\n  let innerNode = node;\n  let depth = 0;\n  while ((innerNode = innerNode.getParent()) !== null) {\n    depth++;\n  }\n  return depth;\n}\n\n/**\n * Takes a node and traverses up its ancestors (toward the root node)\n * in order to find a specific type of node.\n * @param node - the node to begin searching.\n * @param klass - an instance of the type of node to look for.\n * @returns the node of type klass that was passed, or null if none exist.\n */\nfunction $getNearestNodeOfType(node, klass) {\n  let parent = node;\n  while (parent != null) {\n    if (parent instanceof klass) {\n      return parent;\n    }\n    parent = parent.getParent();\n  }\n  return null;\n}\n\n/**\n * Returns the element node of the nearest ancestor, otherwise throws an error.\n * @param startNode - The starting node of the search\n * @returns The ancestor node found\n */\nfunction $getNearestBlockElementAncestorOrThrow(startNode) {\n  const blockNode = $findMatchingParent(startNode, node => lexical.$isElementNode(node) && !node.isInline());\n  if (!lexical.$isElementNode(blockNode)) {\n    {\n      throw Error(`Expected node ${startNode.__key} to have closest block element node.`);\n    }\n  }\n  return blockNode;\n}\n/**\n * Starts with a node and moves up the tree (toward the root node) to find a matching node based on\n * the search parameters of the findFn. (Consider JavaScripts' .find() function where a testing function must be\n * passed as an argument. eg. if( (node) => node.__type === 'div') ) return true; otherwise return false\n * @param startingNode - The node where the search starts.\n * @param findFn - A testing function that returns true if the current node satisfies the testing parameters.\n * @returns A parent node that matches the findFn parameters, or null if one wasn't found.\n */\nfunction $findMatchingParent(startingNode, findFn) {\n  let curr = startingNode;\n  while (curr !== lexical.$getRoot() && curr != null) {\n    if (findFn(curr)) {\n      return curr;\n    }\n    curr = curr.getParent();\n  }\n  return null;\n}\n\n/**\n * Attempts to resolve nested element nodes of the same type into a single node of that type.\n * It is generally used for marks/commenting\n * @param editor - The lexical editor\n * @param targetNode - The target for the nested element to be extracted from.\n * @param cloneNode - See {@link $createMarkNode}\n * @param handleOverlap - Handles any overlap between the node to extract and the targetNode\n * @returns The lexical editor\n */\nfunction registerNestedElementResolver(editor, targetNode, cloneNode, handleOverlap) {\n  const $isTargetNode = node => {\n    return node instanceof targetNode;\n  };\n  const $findMatch = node => {\n    // First validate we don't have any children that are of the target,\n    // as we need to handle them first.\n    const children = node.getChildren();\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      if ($isTargetNode(child)) {\n        return null;\n      }\n    }\n    let parentNode = node;\n    let childNode = node;\n    while (parentNode !== null) {\n      childNode = parentNode;\n      parentNode = parentNode.getParent();\n      if ($isTargetNode(parentNode)) {\n        return {\n          child: childNode,\n          parent: parentNode\n        };\n      }\n    }\n    return null;\n  };\n  const elementNodeTransform = node => {\n    const match = $findMatch(node);\n    if (match !== null) {\n      const {\n        child,\n        parent\n      } = match;\n\n      // Simple path, we can move child out and siblings into a new parent.\n\n      if (child.is(node)) {\n        handleOverlap(parent, node);\n        const nextSiblings = child.getNextSiblings();\n        const nextSiblingsLength = nextSiblings.length;\n        parent.insertAfter(child);\n        if (nextSiblingsLength !== 0) {\n          const newParent = cloneNode(parent);\n          child.insertAfter(newParent);\n          for (let i = 0; i < nextSiblingsLength; i++) {\n            newParent.append(nextSiblings[i]);\n          }\n        }\n        if (!parent.canBeEmpty() && parent.getChildrenSize() === 0) {\n          parent.remove();\n        }\n      }\n    }\n  };\n  return editor.registerNodeTransform(targetNode, elementNodeTransform);\n}\n\n/**\n * Clones the editor and marks it as dirty to be reconciled. If there was a selection,\n * it would be set back to its previous state, or null otherwise.\n * @param editor - The lexical editor\n * @param editorState - The editor's state\n */\nfunction $restoreEditorState(editor, editorState) {\n  const FULL_RECONCILE = 2;\n  const nodeMap = new Map();\n  const activeEditorState = editor._pendingEditorState;\n  for (const [key, node] of editorState._nodeMap) {\n    const clone = selection.$cloneWithProperties(node);\n    if (lexical.$isTextNode(clone)) {\n      clone.__text = node.__text;\n    }\n    nodeMap.set(key, clone);\n  }\n  if (activeEditorState) {\n    activeEditorState._nodeMap = nodeMap;\n  }\n  editor._dirtyType = FULL_RECONCILE;\n  const selection$1 = editorState._selection;\n  lexical.$setSelection(selection$1 === null ? null : selection$1.clone());\n}\n\n/**\n * If the selected insertion area is the root/shadow root node (see {@link lexical!$isRootOrShadowRoot}),\n * the node will be appended there, otherwise, it will be inserted before the insertion area.\n * If there is no selection where the node is to be inserted, it will be appended after any current nodes\n * within the tree, as a child of the root node. A paragraph node will then be added after the inserted node and selected.\n * @param node - The node to be inserted\n * @returns The node after its insertion\n */\nfunction $insertNodeToNearestRoot(node) {\n  const selection = lexical.$getSelection() || lexical.$getPreviousSelection();\n  if (lexical.$isRangeSelection(selection)) {\n    const {\n      focus\n    } = selection;\n    const focusNode = focus.getNode();\n    const focusOffset = focus.offset;\n    if (lexical.$isRootOrShadowRoot(focusNode)) {\n      const focusChild = focusNode.getChildAtIndex(focusOffset);\n      if (focusChild == null) {\n        focusNode.append(node);\n      } else {\n        focusChild.insertBefore(node);\n      }\n      node.selectNext();\n    } else {\n      let splitNode;\n      let splitOffset;\n      if (lexical.$isTextNode(focusNode)) {\n        splitNode = focusNode.getParentOrThrow();\n        splitOffset = focusNode.getIndexWithinParent();\n        if (focusOffset > 0) {\n          splitOffset += 1;\n          focusNode.splitText(focusOffset);\n        }\n      } else {\n        splitNode = focusNode;\n        splitOffset = focusOffset;\n      }\n      const [, rightTree] = lexical.$splitNode(splitNode, splitOffset);\n      rightTree.insertBefore(node);\n      rightTree.selectStart();\n    }\n  } else {\n    if (selection != null) {\n      const nodes = selection.getNodes();\n      nodes[nodes.length - 1].getTopLevelElementOrThrow().insertAfter(node);\n    } else {\n      const root = lexical.$getRoot();\n      root.append(node);\n    }\n    const paragraphNode = lexical.$createParagraphNode();\n    node.insertAfter(paragraphNode);\n    paragraphNode.select();\n  }\n  return node.getLatest();\n}\n\n/**\n * Wraps the node into another node created from a createElementNode function, eg. $createParagraphNode\n * @param node - Node to be wrapped.\n * @param createElementNode - Creates a new lexical element to wrap the to-be-wrapped node and returns it.\n * @returns A new lexical element with the previous node appended within (as a child, including its children).\n */\nfunction $wrapNodeInElement(node, createElementNode) {\n  const elementNode = createElementNode();\n  node.replace(elementNode);\n  elementNode.append(node);\n  return elementNode;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n/**\n * @param object = The instance of the type\n * @param objectClass = The class of the type\n * @returns Whether the object is has the same Klass of the objectClass, ignoring the difference across window (e.g. different iframs)\n */\nfunction objectKlassEquals(object, objectClass) {\n  return object !== null ? Object.getPrototypeOf(object).constructor.name === objectClass.name : false;\n}\n\n/**\n * Filter the nodes\n * @param nodes Array of nodes that needs to be filtered\n * @param filterFn A filter function that returns node if the current node satisfies the condition otherwise null\n * @returns Array of filtered nodes\n */\n\nfunction $filter(nodes, filterFn) {\n  const result = [];\n  for (let i = 0; i < nodes.length; i++) {\n    const node = filterFn(nodes[i]);\n    if (node !== null) {\n      result.push(node);\n    }\n  }\n  return result;\n}\n/**\n * Appends the node before the first child of the parent node\n * @param parent A parent node\n * @param node Node that needs to be appended\n */\nfunction $insertFirst(parent, node) {\n  const firstChild = parent.getFirstChild();\n  if (firstChild !== null) {\n    firstChild.insertBefore(node);\n  } else {\n    parent.append(node);\n  }\n}\n\nexports.$splitNode = lexical.$splitNode;\nexports.isHTMLAnchorElement = lexical.isHTMLAnchorElement;\nexports.isHTMLElement = lexical.isHTMLElement;\nexports.$dfs = $dfs;\nexports.$filter = $filter;\nexports.$findMatchingParent = $findMatchingParent;\nexports.$getNearestBlockElementAncestorOrThrow = $getNearestBlockElementAncestorOrThrow;\nexports.$getNearestNodeOfType = $getNearestNodeOfType;\nexports.$insertFirst = $insertFirst;\nexports.$insertNodeToNearestRoot = $insertNodeToNearestRoot;\nexports.$restoreEditorState = $restoreEditorState;\nexports.$wrapNodeInElement = $wrapNodeInElement;\nexports.addClassNamesToElement = addClassNamesToElement;\nexports.isMimeType = isMimeType;\nexports.markSelection = markSelection;\nexports.mediaFileReader = mediaFileReader;\nexports.mergeRegister = mergeRegister;\nexports.objectKlassEquals = objectKlassEquals;\nexports.positionNodeOnRange = positionNodeOnRange;\nexports.registerNestedElementResolver = registerNestedElementResolver;\nexports.removeClassNamesFromElement = removeClassNamesFromElement;\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict'\nconst LexicalUtils = process.env.NODE_ENV === 'development' ? require('./LexicalUtils.dev.js') : require('./LexicalUtils.prod.js')\nmodule.exports = LexicalUtils;"],
  "mappings": "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",
  "names": ["selection"]
}
