{
  "version": 3,
  "sources": ["../../@lexical/html/LexicalHtml.dev.js", "../../@lexical/html/LexicalHtml.js"],
  "sourcesContent": ["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar selection = require('@lexical/selection');\nvar utils = require('@lexical/utils');\nvar lexical = require('lexical');\n\n/** @module @lexical/html */\n\n/**\n * How you parse your html string to get a document is left up to you. In the browser you can use the native\n * DOMParser API to generate a document (see clipboard.ts), but to use in a headless environment you can use JSDom\n * or an equivilant library and pass in the document here.\n */\nfunction $generateNodesFromDOM(editor, dom) {\n  const elements = dom.body ? dom.body.childNodes : [];\n  let lexicalNodes = [];\n  for (let i = 0; i < elements.length; i++) {\n    const element = elements[i];\n    if (!IGNORE_TAGS.has(element.nodeName)) {\n      const lexicalNode = $createNodesFromDOM(element, editor);\n      if (lexicalNode !== null) {\n        lexicalNodes = lexicalNodes.concat(lexicalNode);\n      }\n    }\n  }\n  return lexicalNodes;\n}\nfunction $generateHtmlFromNodes(editor, selection) {\n  if (typeof document === 'undefined' || typeof window === 'undefined') {\n    throw new Error('To use $generateHtmlFromNodes in headless mode please initialize a headless browser implementation such as JSDom before calling this function.');\n  }\n  const container = document.createElement('div');\n  const root = lexical.$getRoot();\n  const topLevelChildren = root.getChildren();\n  for (let i = 0; i < topLevelChildren.length; i++) {\n    const topLevelNode = topLevelChildren[i];\n    $appendNodesToHTML(editor, topLevelNode, container, selection);\n  }\n  return container.innerHTML;\n}\nfunction $appendNodesToHTML(editor, currentNode, parentElement, selection$1 = null) {\n  let shouldInclude = selection$1 != null ? currentNode.isSelected(selection$1) : true;\n  const shouldExclude = lexical.$isElementNode(currentNode) && currentNode.excludeFromCopy('html');\n  let target = currentNode;\n  if (selection$1 !== null) {\n    let clone = selection.$cloneWithProperties(currentNode);\n    clone = lexical.$isTextNode(clone) && selection$1 != null ? selection.$sliceSelectedTextNodeContent(selection$1, clone) : clone;\n    target = clone;\n  }\n  const children = lexical.$isElementNode(target) ? target.getChildren() : [];\n  const registeredNode = editor._nodes.get(target.getType());\n  let exportOutput;\n\n  // Use HTMLConfig overrides, if available.\n  if (registeredNode && registeredNode.exportDOM !== undefined) {\n    exportOutput = registeredNode.exportDOM(editor, target);\n  } else {\n    exportOutput = target.exportDOM(editor);\n  }\n  const {\n    element,\n    after\n  } = exportOutput;\n  if (!element) {\n    return false;\n  }\n  const fragment = document.createDocumentFragment();\n  for (let i = 0; i < children.length; i++) {\n    const childNode = children[i];\n    const shouldIncludeChild = $appendNodesToHTML(editor, childNode, fragment, selection$1);\n    if (!shouldInclude && lexical.$isElementNode(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection$1, 'html')) {\n      shouldInclude = true;\n    }\n  }\n  if (shouldInclude && !shouldExclude) {\n    if (utils.isHTMLElement(element)) {\n      element.append(fragment);\n    }\n    parentElement.append(element);\n    if (after) {\n      const newElement = after.call(target, element);\n      if (newElement) element.replaceWith(newElement);\n    }\n  } else {\n    parentElement.append(fragment);\n  }\n  return shouldInclude;\n}\nfunction getConversionFunction(domNode, editor) {\n  const {\n    nodeName\n  } = domNode;\n  const cachedConversions = editor._htmlConversions.get(nodeName.toLowerCase());\n  let currentConversion = null;\n  if (cachedConversions !== undefined) {\n    for (const cachedConversion of cachedConversions) {\n      const domConversion = cachedConversion(domNode);\n      if (domConversion !== null && (currentConversion === null || currentConversion.priority < domConversion.priority)) {\n        currentConversion = domConversion;\n      }\n    }\n  }\n  return currentConversion !== null ? currentConversion.conversion : null;\n}\nconst IGNORE_TAGS = new Set(['STYLE', 'SCRIPT']);\nfunction $createNodesFromDOM(node, editor, forChildMap = new Map(), parentLexicalNode) {\n  let lexicalNodes = [];\n  if (IGNORE_TAGS.has(node.nodeName)) {\n    return lexicalNodes;\n  }\n  let currentLexicalNode = null;\n  const transformFunction = getConversionFunction(node, editor);\n  const transformOutput = transformFunction ? transformFunction(node) : null;\n  let postTransform = null;\n  if (transformOutput !== null) {\n    postTransform = transformOutput.after;\n    const transformNodes = transformOutput.node;\n    currentLexicalNode = Array.isArray(transformNodes) ? transformNodes[transformNodes.length - 1] : transformNodes;\n    if (currentLexicalNode !== null) {\n      for (const [, forChildFunction] of forChildMap) {\n        currentLexicalNode = forChildFunction(currentLexicalNode, parentLexicalNode);\n        if (!currentLexicalNode) {\n          break;\n        }\n      }\n      if (currentLexicalNode) {\n        lexicalNodes.push(...(Array.isArray(transformNodes) ? transformNodes : [currentLexicalNode]));\n      }\n    }\n    if (transformOutput.forChild != null) {\n      forChildMap.set(node.nodeName, transformOutput.forChild);\n    }\n  }\n\n  // If the DOM node doesn't have a transformer, we don't know what\n  // to do with it but we still need to process any childNodes.\n  const children = node.childNodes;\n  let childLexicalNodes = [];\n  for (let i = 0; i < children.length; i++) {\n    childLexicalNodes.push(...$createNodesFromDOM(children[i], editor, new Map(forChildMap), currentLexicalNode));\n  }\n  if (postTransform != null) {\n    childLexicalNodes = postTransform(childLexicalNodes);\n  }\n  if (currentLexicalNode == null) {\n    // If it hasn't been converted to a LexicalNode, we hoist its children\n    // up to the same level as it.\n    lexicalNodes = lexicalNodes.concat(childLexicalNodes);\n  } else {\n    if (lexical.$isElementNode(currentLexicalNode)) {\n      // If the current node is a ElementNode after conversion,\n      // we can append all the children to it.\n      currentLexicalNode.append(...childLexicalNodes);\n    }\n  }\n  return lexicalNodes;\n}\n\nexports.$generateHtmlFromNodes = $generateHtmlFromNodes;\nexports.$generateNodesFromDOM = $generateNodesFromDOM;\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict'\nconst LexicalHtml = process.env.NODE_ENV === 'development' ? require('./LexicalHtml.dev.js') : require('./LexicalHtml.prod.js')\nmodule.exports = LexicalHtml;"],
  "mappings": "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",
  "names": ["selection"]
}
