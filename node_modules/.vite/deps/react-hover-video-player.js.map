{
  "version": 3,
  "sources": ["../../react-hover-video-player/src/HoverVideoPlayer.tsx", "../../react-hover-video-player/src/HoverVideoPlayer.styles.ts"],
  "sourcesContent": ["import React, {\n  useRef,\n  useImperativeHandle,\n  useEffect,\n  useState,\n  useCallback,\n} from \"react\";\n\nimport {\n  expandToFillContainerStyle,\n  containerSizingStyles,\n  pausedOverlayWrapperSizingStyles,\n  videoSizingStyles,\n  visibleOverlayStyles,\n  hiddenOverlayStyles,\n  overlayTransitionDurationVar,\n} from \"./HoverVideoPlayer.styles\";\n\nimport { HoverVideoPlayerProps } from \"./HoverVideoPlayer.types\";\n\n/**\n * @component HoverVideoPlayer\n * @license MIT\n *\n * @param {HoverVideoPlayerProps} props\n */\nexport default function HoverVideoPlayer({\n  videoSrc,\n  videoCaptions = null,\n  focused = false,\n  disableDefaultEventHandling = false,\n  hoverTarget = null,\n  onHoverStart = null,\n  onHoverEnd = null,\n  hoverOverlay = null,\n  pausedOverlay = null,\n  loadingOverlay = null,\n  loadingStateTimeout = 200,\n  overlayTransitionDuration = 400,\n  playbackStartDelay = 0,\n  restartOnPaused = false,\n  unloadVideoOnPaused = false,\n  playbackRangeStart = null,\n  playbackRangeEnd = null,\n  muted = true,\n  volume = 1,\n  loop = true,\n  preload = undefined,\n  crossOrigin = undefined,\n  controls = false,\n  controlsList = undefined,\n  disableRemotePlayback = true,\n  disablePictureInPicture = true,\n  style = undefined,\n  hoverOverlayWrapperClassName = undefined,\n  hoverOverlayWrapperStyle = undefined,\n  pausedOverlayWrapperClassName = undefined,\n  pausedOverlayWrapperStyle = undefined,\n  loadingOverlayWrapperClassName = undefined,\n  loadingOverlayWrapperStyle = undefined,\n  videoId = undefined,\n  videoClassName = undefined,\n  videoRef: forwardedVideoRef = null,\n  videoStyle = undefined,\n  sizingMode = \"video\",\n  ...spreadableProps\n}: HoverVideoPlayerProps): JSX.Element {\n  // Element refs\n  const containerRef = useRef<HTMLDivElement>(null);\n  const videoRef = useRef<HTMLVideoElement>(null);\n  // Forward out local videoRef along to the videoRef prop\n  useImperativeHandle(\n    forwardedVideoRef,\n    () => videoRef.current as HTMLVideoElement\n  );\n\n  // Effects set attributes on the video which can't be done via props\n  useEffect(() => {\n    // Manually setting the `muted` attribute on the video element via an effect in order\n    // to avoid a know React issue with the `muted` prop not applying correctly on initial render\n    // https://github.com/facebook/react/issues/10389\n    if (videoRef.current) videoRef.current.muted = muted;\n  }, [muted]);\n  useEffect(() => {\n    // Set the video's volume to match the `volume` prop\n    // Note that this will have no effect if the `muted` prop is set to true\n    if (videoRef.current) videoRef.current.volume = volume;\n  }, [volume]);\n  // React does not support directly setting disableRemotePlayback or disablePictureInPicture directly\n  // via the video element's props, so we have to manually set them in an effect\n  useEffect(() => {\n    if (videoRef.current)\n      videoRef.current.disableRemotePlayback = disableRemotePlayback;\n  }, [disableRemotePlayback]);\n  useEffect(() => {\n    if (videoRef.current)\n      videoRef.current.disablePictureInPicture = disablePictureInPicture;\n  }, [disablePictureInPicture]);\n\n  useEffect(() => {\n    const videoElement = videoRef.current;\n\n    if (videoElement && playbackRangeStart) {\n      videoElement.currentTime = playbackRangeStart;\n    }\n  }, [playbackRangeStart]);\n\n  const [hoverTargetElement, setHoverTargetElement] = useState<Node | null>(\n    null\n  );\n\n  useEffect(() => {\n    // Default to the container element unless a hoverTarget prop is provided\n    let element: Node | null = containerRef.current;\n\n    if (hoverTarget) {\n      // Get the hover target element from the hoverTarget prop, or default to the component's container div\n      // A `hoverTarget` value could be a function, a DOM element, or a React ref, so\n      // figure out which one it is and get the hover target element out of it accordingly\n      if (typeof hoverTarget === \"function\") {\n        element = hoverTarget();\n      } else if (hoverTarget instanceof Node) {\n        element = hoverTarget;\n      } else if (hoverTarget && hoverTarget.hasOwnProperty(\"current\")) {\n        element = hoverTarget.current;\n      } else {\n        console.error(\n          \"HoverVideoPlayer was unable to get a usable hover target element. Please check your usage of the `hoverTarget` prop.\"\n        );\n      }\n    }\n\n    setHoverTargetElement(element);\n  }, [hoverTarget]);\n\n  // Keep a ref for the time which the video should be started from next time it is played\n  // This is useful if the video gets unloaded and we want to restore it to the time it was\n  // at before if the user tries playing it again\n  const nextVideoStartTimeRef = useRef<number | null>(null);\n\n  // Whether the user is hovering over the hover target, meaning we should be trying to play the video\n  const [isHovering, setIsHovering] = useState(false);\n  // Whether the video is currently in a loading state, meaning it's not ready to be played yet\n  const [isLoading, setIsLoading] = useState(false);\n  // Whether the video is currently playing or not\n  const [isPlaying, setIsPlaying] = useState(false);\n\n  const isHoveringRef = useRef<boolean>();\n  isHoveringRef.current = isHovering;\n\n  const playTimeoutRef = useRef<number | undefined>();\n  const pauseTimeoutRef = useRef<number | undefined>();\n\n  const cancelTimeouts = useCallback(() => {\n    // Cancel any previously active pause or playback attempts\n    window.clearTimeout(playTimeoutRef.current);\n    window.clearTimeout(pauseTimeoutRef.current);\n  }, []);\n\n  const hasPausedOverlay = Boolean(pausedOverlay);\n  const hasHoverOverlay = Boolean(hoverOverlay);\n\n  // If we have a paused or hover overlay, the player should wait\n  // for the overlay(s) to finish transitioning back in before we\n  // pause the video\n  const shouldWaitForOverlayTransitionBeforePausing =\n    hasPausedOverlay || hasHoverOverlay;\n\n  useEffect(() => {\n    const videoElement = videoRef.current;\n\n    if (!hoverTargetElement || !videoElement) return undefined;\n\n    const onHoverStart = () => {\n      // Bail out if we're already hovering\n      if (isHoveringRef.current) return;\n\n      // Cancel any previously active pause or playback attempts\n      cancelTimeouts();\n\n      setIsHovering(true);\n    };\n    const onHoverEnd = () => {\n      cancelTimeouts();\n\n      setIsHovering(false);\n    };\n\n    hoverTargetElement.addEventListener(\"hvp:hoverStart\", onHoverStart);\n    hoverTargetElement.addEventListener(\"hvp:hoverEnd\", onHoverEnd);\n\n    return () => {\n      hoverTargetElement.removeEventListener(\"hvp:hoverStart\", onHoverStart);\n      hoverTargetElement.removeEventListener(\"hvp:hoverEnd\", onHoverEnd);\n    };\n  }, [\n    cancelTimeouts,\n    hoverTargetElement,\n    overlayTransitionDuration,\n    playbackRangeStart,\n    restartOnPaused,\n    shouldWaitForOverlayTransitionBeforePausing,\n  ]);\n\n  const playVideo = useCallback(() => {\n    const videoElement = videoRef.current;\n    if (!videoElement) return;\n\n    videoElement.play().catch((error: DOMException) => {\n      // Suppress logging for \"AbortError\" errors, which are thrown when the video is paused while it was trying to play.\n      // These errors are expected and happen often, so they can be safely ignored.\n      if (error.name === \"AbortError\") {\n        return;\n      }\n\n      // Additional handling for when browsers block playback for unmuted videos.\n      // This is unfortunately necessary because most modern browsers do not allow playing videos with audio\n      //  until the user has \"interacted\" with the page by clicking somewhere at least once; mouseenter events\n      //  don't count.\n      // If the video isn't muted and playback failed with a `NotAllowedError`, this means the browser blocked\n      // playing the video because the user hasn't clicked anywhere on the page yet.\n      if (!videoElement.muted && error.name === \"NotAllowedError\") {\n        console.warn(\n          \"HoverVideoPlayer: Playback with sound was blocked by the browser. Attempting to play again with the video muted; audio will be restored if the user clicks on the page.\"\n        );\n        // Mute the video and attempt to play again\n        videoElement.muted = true;\n        playVideo();\n\n        // When the user clicks on the document, unmute the video since we should now\n        // be free to play audio\n        const onClickDocument = () => {\n          videoElement.muted = false;\n\n          // Clean up the event listener so it is only fired once\n          document.removeEventListener(\"click\", onClickDocument);\n        };\n        document.addEventListener(\"click\", onClickDocument);\n      } else {\n        // Log any other playback errors with console.error\n        console.error(`HoverVideoPlayer: ${error.message}`);\n      }\n    });\n  }, []);\n\n  // Effect attempts to start playing the video if the user is hovering over the hover target\n  // and the video is loaded enough to be played\n  useEffect(() => {\n    const videoElement = videoRef.current;\n    if (!videoElement) return;\n\n    if (isHovering && !isLoading && !isPlaying) {\n      if (\n        nextVideoStartTimeRef.current !== null &&\n        videoElement.currentTime !== nextVideoStartTimeRef.current\n      ) {\n        videoElement.currentTime = nextVideoStartTimeRef.current;\n      }\n\n      if (playbackStartDelay) {\n        playTimeoutRef.current = window.setTimeout(\n          playVideo,\n          playbackStartDelay\n        );\n      } else {\n        playVideo();\n      }\n    }\n  }, [isHovering, isLoading, isPlaying, playVideo, playbackStartDelay]);\n\n  // Effect pauses the video if the user is no longer hovering over the hover target\n  // and the video is currently playing\n  useEffect(() => {\n    const videoElement = videoRef.current;\n    if (!videoElement) return;\n\n    if (!isHovering && (isPlaying || isLoading)) {\n      const pauseVideo = () => {\n        videoElement.pause();\n\n        // Performing post-save cleanup tasks in here rather than the onPause listener\n        // because onPause can also be called when the video reaches the end of a playback range\n        // and it's just simpler to deal with that separately\n        if (restartOnPaused) {\n          videoElement.currentTime = playbackRangeStart || 0;\n        }\n        nextVideoStartTimeRef.current = videoElement.currentTime;\n      };\n\n      if (shouldWaitForOverlayTransitionBeforePausing) {\n        // If we have a paused overlay, the player should wait\n        // for the overlay(s) to finish transitioning back in before we\n        // pause the video\n        pauseTimeoutRef.current = window.setTimeout(\n          pauseVideo,\n          overlayTransitionDuration\n        );\n      } else {\n        pauseVideo();\n      }\n    }\n  }, [\n    isHovering,\n    isLoading,\n    isPlaying,\n    overlayTransitionDuration,\n    playbackRangeStart,\n    restartOnPaused,\n    shouldWaitForOverlayTransitionBeforePausing,\n  ]);\n\n  // Effect cancels any pending timeouts when the component unmounts\n  useEffect(() => () => cancelTimeouts(), [cancelTimeouts]);\n\n  // Keeping hover callbacks as refs because we want to be able to access them from within our\n  // onHoverStart and onHoverEnd event listeners without needing to re-run the\n  // event setup effect every time they change\n  const onHoverStartCallbackRef = useRef<typeof onHoverStart>();\n  onHoverStartCallbackRef.current = onHoverStart;\n\n  const onHoverEndCallbackRef = useRef<typeof onHoverEnd>();\n  onHoverEndCallbackRef.current = onHoverEnd;\n\n  // Effect sets up event listeners for hover events on hover target\n  useEffect(() => {\n    // If default event handling is disabled, we shouldn't check for touch events outside of the player\n    if (disableDefaultEventHandling || !hoverTargetElement) return undefined;\n\n    const onHoverStart = () => {\n      hoverTargetElement.dispatchEvent(new Event(\"hvp:hoverStart\"));\n      onHoverStartCallbackRef.current?.();\n    };\n    const onHoverEnd = () => {\n      hoverTargetElement.dispatchEvent(new Event(\"hvp:hoverEnd\"));\n      onHoverEndCallbackRef.current?.();\n    };\n\n    // Mouse events\n    hoverTargetElement.addEventListener(\"mouseenter\", onHoverStart);\n    hoverTargetElement.addEventListener(\"mouseleave\", onHoverEnd);\n\n    // Focus/blur\n    hoverTargetElement.addEventListener(\"focus\", onHoverStart);\n    hoverTargetElement.addEventListener(\"blur\", onHoverEnd);\n\n    // Touch events\n    const touchStartListenerOptions = { passive: true };\n\n    hoverTargetElement.addEventListener(\n      \"touchstart\",\n      onHoverStart,\n      touchStartListenerOptions\n    );\n    // Event listener pauses the video when the user touches somewhere outside of the player\n    const onWindowTouchStart = (event: TouchEvent) => {\n      if (\n        !(event.target instanceof Node) ||\n        !hoverTargetElement.contains(event.target)\n      ) {\n        onHoverEnd();\n      }\n    };\n\n    window.addEventListener(\n      \"touchstart\",\n      onWindowTouchStart,\n      touchStartListenerOptions\n    );\n\n    // Return a cleanup function that removes all event listeners\n    return () => {\n      hoverTargetElement.removeEventListener(\"mouseenter\", onHoverStart);\n      hoverTargetElement.removeEventListener(\"mouseleave\", onHoverEnd);\n      hoverTargetElement.removeEventListener(\"focus\", onHoverStart);\n      hoverTargetElement.removeEventListener(\"blur\", onHoverEnd);\n      hoverTargetElement.removeEventListener(\"touchstart\", onHoverStart);\n      window.removeEventListener(\"touchstart\", onWindowTouchStart);\n    };\n  }, [disableDefaultEventHandling, hoverTargetElement]);\n\n  // Defaulting the ref to false rather than the initial value of the focused prop because\n  // if focused is true initially, we want to run the effect, but if it's false, we don't\n  const previousFocusedRef = useRef<boolean>(false);\n\n  // Effect dispatches hover start/end events on the target element when the focused prop changes\n  useEffect(() => {\n    if (!hoverTargetElement) return;\n\n    if (previousFocusedRef.current !== focused) {\n      previousFocusedRef.current = focused;\n\n      if (focused) {\n        hoverTargetElement.dispatchEvent(new Event(\"hvp:hoverStart\"));\n      } else {\n        hoverTargetElement.dispatchEvent(new Event(\"hvp:hoverEnd\"));\n      }\n    }\n  }, [hoverTargetElement, focused]);\n\n  const currentVideoSrc = useRef(videoSrc);\n  let shouldReloadVideoSrc = false;\n  if (videoSrc !== currentVideoSrc.current && !isHovering && !isPlaying) {\n    currentVideoSrc.current = videoSrc;\n    shouldReloadVideoSrc = true;\n  }\n\n  const hasStringSrc = typeof currentVideoSrc.current === \"string\";\n\n  useEffect(() => {\n    const videoElement = videoRef.current;\n    if (!videoElement) return;\n\n    if (shouldReloadVideoSrc) {\n      // If the video element doesn't have a loaded source or the source has changed since the\n      // last time we played the video, make sure to force the video to load the most up-to-date sources\n      videoElement.load();\n      // Reset the next start time to the start of the video\n      nextVideoStartTimeRef.current = playbackRangeStart || 0;\n    }\n  }, [playbackRangeStart, shouldReloadVideoSrc]);\n\n  // If the video's sources should be unloaded when it's paused and the video is not currently active, we can unload the video's sources.\n  // We will remove the video's <source> tags in this render and then call video.load() in an effect to\n  // fully unload the video\n  const shouldUnloadVideo = unloadVideoOnPaused && !isHovering && !isPlaying;\n\n  useEffect(() => {\n    if (shouldUnloadVideo) {\n      // Re-load the video with the sources removed so we unload everything from memory\n      videoRef.current?.load();\n    }\n  }, [shouldUnloadVideo]);\n\n  const shouldShowLoadingOverlay = isHovering && !isPlaying;\n  // Show a paused overlay when the user isn't hovering or when the user is hovering\n  // but the video is still loading\n  const shouldShowPausedOverlay = !isHovering || (isHovering && !isPlaying);\n\n  const isUsingPlaybackRange =\n    playbackRangeStart !== null || playbackRangeEnd !== null;\n\n  const hasLoadingOverlay = Boolean(loadingOverlay);\n\n  return (\n    <div\n      ref={containerRef}\n      style={{\n        [overlayTransitionDurationVar as string]: `${overlayTransitionDuration}ms`,\n        ...containerSizingStyles[sizingMode],\n        position: \"relative\",\n        ...style,\n      }}\n      {...spreadableProps}\n    >\n      {hasPausedOverlay ? (\n        <div\n          style={{\n            ...pausedOverlayWrapperSizingStyles[sizingMode],\n            zIndex: 1,\n            ...(shouldShowPausedOverlay\n              ? visibleOverlayStyles\n              : hiddenOverlayStyles),\n            ...pausedOverlayWrapperStyle,\n          }}\n          className={pausedOverlayWrapperClassName}\n        >\n          {pausedOverlay}\n        </div>\n      ) : null}\n      {hasLoadingOverlay ? (\n        <div\n          style={{\n            ...expandToFillContainerStyle,\n            zIndex: 2,\n            transitionDelay: loadingStateTimeout\n              ? `${loadingStateTimeout}ms`\n              : undefined,\n            ...(shouldShowLoadingOverlay\n              ? visibleOverlayStyles\n              : hiddenOverlayStyles),\n            ...loadingOverlayWrapperStyle,\n          }}\n          className={loadingOverlayWrapperClassName}\n        >\n          {loadingOverlay}\n        </div>\n      ) : null}\n      {hasHoverOverlay ? (\n        <div\n          style={{\n            ...expandToFillContainerStyle,\n            zIndex: 3,\n            // Show the hover overlay when the player is hovered/playing\n            ...(isHovering ? visibleOverlayStyles : hiddenOverlayStyles),\n            ...hoverOverlayWrapperStyle,\n          }}\n          className={hoverOverlayWrapperClassName}\n        >\n          {hoverOverlay}\n        </div>\n      ) : null}\n      {/* eslint-disable-next-line jsx-a11y/media-has-caption */}\n      <video\n        src={\n          hasStringSrc && !shouldUnloadVideo\n            ? (currentVideoSrc.current as string)\n            : undefined\n        }\n        // If a playback range is set, the loop attribute will not work correctly so there's no point in setting it here;\n        // in that case, we will manually implement this behavior\n        loop={isUsingPlaybackRange ? false : loop}\n        playsInline\n        preload={preload}\n        crossOrigin={crossOrigin}\n        ref={videoRef}\n        style={{\n          ...videoSizingStyles[sizingMode],\n          objectFit: \"cover\",\n          ...videoStyle,\n        }}\n        controls={controls}\n        controlsList={controlsList}\n        className={videoClassName}\n        id={videoId}\n        onPlaying={() => setIsPlaying(true)}\n        onPause={() => setIsPlaying(false)}\n        onEnded={() => setIsPlaying(false)}\n        // Update state when the video starts loading\n        onLoadStart={() => setIsLoading(true)}\n        // Update that we're no longer loading when the video has suspended loading data\n        onSuspend={() => setIsLoading(false)}\n        // Update that we are loading if the video is waiting for data to continue playing\n        onWaiting={() => setIsLoading(true)}\n        onLoadedData={() => {\n          // As video data is loaded, check if we've loaded enough data to start playing the video\n          // and update state accordingly\n          setIsLoading(\n            (videoRef.current?.readyState || 0) <\n              HTMLMediaElement.HAVE_ENOUGH_DATA\n          );\n        }}\n        onAbort={() => {\n          // If loading is aborted, update state\n          setIsLoading(false);\n        }}\n        onTimeUpdate={\n          // If there's a playback range set, the traditional `loop` video prop won't work correctly so\n          // we'll need watch the video's time as it plays and manually keep it within the bounds of the range\n          isUsingPlaybackRange\n            ? () => {\n                const videoElement = videoRef.current;\n                if (!videoElement) return;\n\n                const maxVideoTime = playbackRangeEnd || videoElement.duration;\n                const minVideoTime = playbackRangeStart || 0;\n\n                const { currentTime } = videoElement;\n\n                if (loop && currentTime >= maxVideoTime) {\n                  // If the video should loop and is >= the max video time,\n                  // loop it back around to the start\n                  const startTime = playbackRangeStart || 0;\n                  videoElement.currentTime = startTime;\n\n                  // If the video is paused but the user is still hovering,\n                  // meaning it should continue to play, call play() to keep it going\n                  if (\n                    isHovering &&\n                    (videoElement.paused || videoElement.ended)\n                  ) {\n                    playVideo();\n                  }\n                } else if (currentTime > maxVideoTime) {\n                  // If the video shouldn't loop but we've exceeded the max video time,\n                  // clamp it to the max time and pause it\n                  videoElement.pause();\n                  videoElement.currentTime = maxVideoTime;\n                } else if (currentTime < minVideoTime) {\n                  // If the video's time somehow ended up before the min video time,\n                  // clamp it to the min time\n                  videoElement.currentTime = minVideoTime;\n                }\n              }\n            : undefined\n        }\n      >\n        {shouldUnloadVideo || hasStringSrc ? null : currentVideoSrc.current}\n        {videoCaptions}\n      </video>\n    </div>\n  );\n}\n", "import React from 'react';\n\ninterface SizingModeStyle {\n  video: React.CSSProperties | null;\n  overlay: React.CSSProperties | null;\n  container: React.CSSProperties | null;\n  manual: React.CSSProperties | null;\n}\n\n// CSS styles to make some contents in the player expand to fill the container\nexport const expandToFillContainerStyle: React.CSSProperties = {\n  position: 'absolute',\n  width: '100%',\n  height: '100%',\n  top: 0,\n  bottom: 0,\n  left: 0,\n  right: 0,\n};\n\nconst containerMatchContentDimensionsStyle: React.CSSProperties = {\n  display: 'inline-block',\n};\n\nexport const containerSizingStyles: SizingModeStyle = {\n  video: containerMatchContentDimensionsStyle,\n  overlay: containerMatchContentDimensionsStyle,\n  container: null,\n  manual: null,\n};\n\n// Styles to apply to the paused overlay wrapper for each sizing mode\nexport const pausedOverlayWrapperSizingStyles: SizingModeStyle = {\n  // Sizing should be based on the video element, so make the overlay\n  // expand to cover the player's container element\n  video: expandToFillContainerStyle,\n  // Sizing should be based on the paused overlay, so set position: relative\n  // to make it occupy space in the document flow\n  overlay: {\n    position: 'relative',\n  },\n  // Sizing should be based on the player's container element, so make the overlay\n  // expand to cover it\n  container: expandToFillContainerStyle,\n  // Don't apply any preset styling to the overlay\n  manual: null,\n};\n\n// Styles to apply to the video element for each sizing mode\nexport const videoSizingStyles: SizingModeStyle = {\n  // Sizing should be based on the video element, so set display: block\n  // to make sure it occupies space in the document flow\n  video: {\n    display: 'block',\n    // Ensure the video is sized relative to the container's width\n    // rather than the video asset's native width\n    width: '100%',\n  },\n  // Make the video element expand to cover the container if we're sizing\n  // based on the overlay or container\n  overlay: expandToFillContainerStyle,\n  container: expandToFillContainerStyle,\n  // Don't apply any preset styling to the video\n  manual: null,\n};\n\nexport const overlayTransitionDurationVar = \"--hvp-overlay-transition-duration\";\n\nexport const visibleOverlayStyles: React.CSSProperties = {\n  visibility: 'visible',\n  opacity: 1,\n  transitionProperty: 'opacity',\n  transitionDuration: `var(${overlayTransitionDurationVar})`,\n};\n\nexport const hiddenOverlayStyles: React.CSSProperties = {\n  visibility: 'hidden',\n  opacity: 0,\n  transitionProperty: 'opacity, visibility',\n  transitionDuration: `var(${overlayTransitionDurationVar}), 0s`,\n  transitionDelay: `0s, var(${overlayTransitionDurationVar})`,\n};\n"],
  "mappings": "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",
  "names": ["onHoverStart", "onHoverEnd", "_a", "React"]
}
