{
  "version": 3,
  "sources": ["../../@lexical/markdown/LexicalMarkdown.dev.js", "../../@lexical/markdown/LexicalMarkdown.js"],
  "sourcesContent": ["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar lexical = require('lexical');\nvar code = require('@lexical/code');\nvar list = require('@lexical/list');\nvar richText = require('@lexical/rich-text');\nvar utils = require('@lexical/utils');\nvar link = require('@lexical/link');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction indexBy(list, callback) {\n  const index = {};\n  for (const item of list) {\n    const key = callback(item);\n    if (index[key]) {\n      index[key].push(item);\n    } else {\n      index[key] = [item];\n    }\n  }\n  return index;\n}\nfunction transformersByType(transformers) {\n  const byType = indexBy(transformers, t => t.type);\n  return {\n    element: byType.element || [],\n    textFormat: byType['text-format'] || [],\n    textMatch: byType['text-match'] || []\n  };\n}\nconst PUNCTUATION_OR_SPACE = /[!-/:-@[-`{-~\\s]/;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction createMarkdownExport(transformers) {\n  const byType = transformersByType(transformers);\n\n  // Export only uses text formats that are responsible for single format\n  // e.g. it will filter out *** (bold, italic) and instead use separate ** and *\n  const textFormatTransformers = byType.textFormat.filter(transformer => transformer.format.length === 1);\n  return node => {\n    const output = [];\n    const children = (node || lexical.$getRoot()).getChildren();\n    for (const child of children) {\n      const result = exportTopLevelElements(child, byType.element, textFormatTransformers, byType.textMatch);\n      if (result != null) {\n        output.push(result);\n      }\n    }\n    return output.join('\\n\\n');\n  };\n}\nfunction exportTopLevelElements(node, elementTransformers, textTransformersIndex, textMatchTransformers) {\n  for (const transformer of elementTransformers) {\n    const result = transformer.export(node, _node => exportChildren(_node, textTransformersIndex, textMatchTransformers));\n    if (result != null) {\n      return result;\n    }\n  }\n  if (lexical.$isElementNode(node)) {\n    return exportChildren(node, textTransformersIndex, textMatchTransformers);\n  } else if (lexical.$isDecoratorNode(node)) {\n    return node.getTextContent();\n  } else {\n    return null;\n  }\n}\nfunction exportChildren(node, textTransformersIndex, textMatchTransformers) {\n  const output = [];\n  const children = node.getChildren();\n  mainLoop: for (const child of children) {\n    for (const transformer of textMatchTransformers) {\n      const result = transformer.export(child, parentNode => exportChildren(parentNode, textTransformersIndex, textMatchTransformers), (textNode, textContent) => exportTextFormat(textNode, textContent, textTransformersIndex));\n      if (result != null) {\n        output.push(result);\n        continue mainLoop;\n      }\n    }\n    if (lexical.$isLineBreakNode(child)) {\n      output.push('\\n');\n    } else if (lexical.$isTextNode(child)) {\n      output.push(exportTextFormat(child, child.getTextContent(), textTransformersIndex));\n    } else if (lexical.$isElementNode(child)) {\n      output.push(exportChildren(child, textTransformersIndex, textMatchTransformers));\n    } else if (lexical.$isDecoratorNode(child)) {\n      output.push(child.getTextContent());\n    }\n  }\n  return output.join('');\n}\nfunction exportTextFormat(node, textContent, textTransformers) {\n  // This function handles the case of a string looking like this: \"   foo   \"\n  // Where it would be invalid markdown to generate: \"**   foo   **\"\n  // We instead want to trim the whitespace out, apply formatting, and then\n  // bring the whitespace back. So our returned string looks like this: \"   **foo**   \"\n  const frozenString = textContent.trim();\n  let output = frozenString;\n  const applied = new Set();\n  for (const transformer of textTransformers) {\n    const format = transformer.format[0];\n    const tag = transformer.tag;\n    if (hasFormat(node, format) && !applied.has(format)) {\n      // Multiple tags might be used for the same format (*, _)\n      applied.add(format);\n      // Prevent adding opening tag is already opened by the previous sibling\n      const previousNode = getTextSibling(node, true);\n      if (!hasFormat(previousNode, format)) {\n        output = tag + output;\n      }\n\n      // Prevent adding closing tag if next sibling will do it\n      const nextNode = getTextSibling(node, false);\n      if (!hasFormat(nextNode, format)) {\n        output += tag;\n      }\n    }\n  }\n\n  // Replace trimmed version of textContent ensuring surrounding whitespace is not modified\n  return textContent.replace(frozenString, output);\n}\n\n// Get next or previous text sibling a text node, including cases\n// when it's a child of inline element (e.g. link)\nfunction getTextSibling(node, backward) {\n  let sibling = backward ? node.getPreviousSibling() : node.getNextSibling();\n  if (!sibling) {\n    const parent = node.getParentOrThrow();\n    if (parent.isInline()) {\n      sibling = backward ? parent.getPreviousSibling() : parent.getNextSibling();\n    }\n  }\n  while (sibling) {\n    if (lexical.$isElementNode(sibling)) {\n      if (!sibling.isInline()) {\n        break;\n      }\n      const descendant = backward ? sibling.getLastDescendant() : sibling.getFirstDescendant();\n      if (lexical.$isTextNode(descendant)) {\n        return descendant;\n      } else {\n        sibling = backward ? sibling.getPreviousSibling() : sibling.getNextSibling();\n      }\n    }\n    if (lexical.$isTextNode(sibling)) {\n      return sibling;\n    }\n    if (!lexical.$isElementNode(sibling)) {\n      return null;\n    }\n  }\n  return null;\n}\nfunction hasFormat(node, format) {\n  return lexical.$isTextNode(node) && node.hasFormat(format);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst documentMode = CAN_USE_DOM && 'documentMode' in document ? document.documentMode : null;\nCAN_USE_DOM && /Mac|iPod|iPhone|iPad/.test(navigator.platform);\nCAN_USE_DOM && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nCAN_USE_DOM && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;\nconst IS_SAFARI = CAN_USE_DOM && /Version\\/[\\d.]+.*Safari/.test(navigator.userAgent);\nconst IS_IOS = CAN_USE_DOM && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\nCAN_USE_DOM && /Android/.test(navigator.userAgent);\n\n// Keep these in case we need to use them in the future.\n// export const IS_WINDOWS: boolean = CAN_USE_DOM && /Win/.test(navigator.platform);\nconst IS_CHROME = CAN_USE_DOM && /^(?=.*Chrome).*/i.test(navigator.userAgent);\n// export const canUseTextInputEvent: boolean = CAN_USE_DOM && 'TextEvent' in window && !documentMode;\n\nconst IS_APPLE_WEBKIT = CAN_USE_DOM && /AppleWebKit\\/[\\d.]+/.test(navigator.userAgent) && !IS_CHROME;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst MARKDOWN_EMPTY_LINE_REG_EXP = /^\\s{0,3}$/;\nconst CODE_BLOCK_REG_EXP = /^```(\\w{1,10})?\\s?$/;\nfunction createMarkdownImport(transformers) {\n  const byType = transformersByType(transformers);\n  const textFormatTransformersIndex = createTextFormatTransformersIndex(byType.textFormat);\n  return (markdownString, node) => {\n    const lines = markdownString.split('\\n');\n    const linesLength = lines.length;\n    const root = node || lexical.$getRoot();\n    root.clear();\n    for (let i = 0; i < linesLength; i++) {\n      const lineText = lines[i];\n      // Codeblocks are processed first as anything inside such block\n      // is ignored for further processing\n      // TODO:\n      // Abstract it to be dynamic as other transformers (add multiline match option)\n      const [codeBlockNode, shiftedIndex] = importCodeBlock(lines, i, root);\n      if (codeBlockNode != null) {\n        i = shiftedIndex;\n        continue;\n      }\n      importBlocks(lineText, root, byType.element, textFormatTransformersIndex, byType.textMatch);\n    }\n\n    // Removing empty paragraphs as md does not really\n    // allow empty lines and uses them as dilimiter\n    const children = root.getChildren();\n    for (const child of children) {\n      if (isEmptyParagraph(child)) {\n        child.remove();\n      }\n    }\n    if (lexical.$getSelection() !== null) {\n      root.selectEnd();\n    }\n  };\n}\nfunction isEmptyParagraph(node) {\n  if (!lexical.$isParagraphNode(node)) {\n    return false;\n  }\n  const firstChild = node.getFirstChild();\n  return firstChild == null || node.getChildrenSize() === 1 && lexical.$isTextNode(firstChild) && MARKDOWN_EMPTY_LINE_REG_EXP.test(firstChild.getTextContent());\n}\nfunction importBlocks(lineText, rootNode, elementTransformers, textFormatTransformersIndex, textMatchTransformers) {\n  const lineTextTrimmed = lineText.trim();\n  const textNode = lexical.$createTextNode(lineTextTrimmed);\n  const elementNode = lexical.$createParagraphNode();\n  elementNode.append(textNode);\n  rootNode.append(elementNode);\n  for (const {\n    regExp,\n    replace\n  } of elementTransformers) {\n    const match = lineText.match(regExp);\n    if (match) {\n      textNode.setTextContent(lineText.slice(match[0].length));\n      replace(elementNode, [textNode], match, true);\n      break;\n    }\n  }\n  importTextFormatTransformers(textNode, textFormatTransformersIndex, textMatchTransformers);\n\n  // If no transformer found and we left with original paragraph node\n  // can check if its content can be appended to the previous node\n  // if it's a paragraph, quote or list\n  if (elementNode.isAttached() && lineTextTrimmed.length > 0) {\n    const previousNode = elementNode.getPreviousSibling();\n    if (lexical.$isParagraphNode(previousNode) || richText.$isQuoteNode(previousNode) || list.$isListNode(previousNode)) {\n      let targetNode = previousNode;\n      if (list.$isListNode(previousNode)) {\n        const lastDescendant = previousNode.getLastDescendant();\n        if (lastDescendant == null) {\n          targetNode = null;\n        } else {\n          targetNode = utils.$findMatchingParent(lastDescendant, list.$isListItemNode);\n        }\n      }\n      if (targetNode != null && targetNode.getTextContentSize() > 0) {\n        targetNode.splice(targetNode.getChildrenSize(), 0, [lexical.$createLineBreakNode(), ...elementNode.getChildren()]);\n        elementNode.remove();\n      }\n    }\n  }\n}\nfunction importCodeBlock(lines, startLineIndex, rootNode) {\n  const openMatch = lines[startLineIndex].match(CODE_BLOCK_REG_EXP);\n  if (openMatch) {\n    let endLineIndex = startLineIndex;\n    const linesLength = lines.length;\n    while (++endLineIndex < linesLength) {\n      const closeMatch = lines[endLineIndex].match(CODE_BLOCK_REG_EXP);\n      if (closeMatch) {\n        const codeBlockNode = code.$createCodeNode(openMatch[1]);\n        const textNode = lexical.$createTextNode(lines.slice(startLineIndex + 1, endLineIndex).join('\\n'));\n        codeBlockNode.append(textNode);\n        rootNode.append(codeBlockNode);\n        return [codeBlockNode, endLineIndex];\n      }\n    }\n  }\n  return [null, startLineIndex];\n}\n\n// Processing text content and replaces text format tags.\n// It takes outermost tag match and its content, creates text node with\n// format based on tag and then recursively executed over node's content\n//\n// E.g. for \"*Hello **world**!*\" string it will create text node with\n// \"Hello **world**!\" content and italic format and run recursively over\n// its content to transform \"**world**\" part\nfunction importTextFormatTransformers(textNode, textFormatTransformersIndex, textMatchTransformers) {\n  const textContent = textNode.getTextContent();\n  const match = findOutermostMatch(textContent, textFormatTransformersIndex);\n  if (!match) {\n    // Once text format processing is done run text match transformers, as it\n    // only can span within single text node (unline formats that can cover multiple nodes)\n    importTextMatchTransformers(textNode, textMatchTransformers);\n    return;\n  }\n  let currentNode, remainderNode, leadingNode;\n\n  // If matching full content there's no need to run splitText and can reuse existing textNode\n  // to update its content and apply format. E.g. for **_Hello_** string after applying bold\n  // format (**) it will reuse the same text node to apply italic (_)\n  if (match[0] === textContent) {\n    currentNode = textNode;\n  } else {\n    const startIndex = match.index || 0;\n    const endIndex = startIndex + match[0].length;\n    if (startIndex === 0) {\n      [currentNode, remainderNode] = textNode.splitText(endIndex);\n    } else {\n      [leadingNode, currentNode, remainderNode] = textNode.splitText(startIndex, endIndex);\n    }\n  }\n  currentNode.setTextContent(match[2]);\n  const transformer = textFormatTransformersIndex.transformersByTag[match[1]];\n  if (transformer) {\n    for (const format of transformer.format) {\n      if (!currentNode.hasFormat(format)) {\n        currentNode.toggleFormat(format);\n      }\n    }\n  }\n\n  // Recursively run over inner text if it's not inline code\n  if (!currentNode.hasFormat('code')) {\n    importTextFormatTransformers(currentNode, textFormatTransformersIndex, textMatchTransformers);\n  }\n\n  // Run over leading/remaining text if any\n  if (leadingNode) {\n    importTextFormatTransformers(leadingNode, textFormatTransformersIndex, textMatchTransformers);\n  }\n  if (remainderNode) {\n    importTextFormatTransformers(remainderNode, textFormatTransformersIndex, textMatchTransformers);\n  }\n}\nfunction importTextMatchTransformers(textNode_, textMatchTransformers) {\n  let textNode = textNode_;\n  mainLoop: while (textNode) {\n    for (const transformer of textMatchTransformers) {\n      const match = textNode.getTextContent().match(transformer.importRegExp);\n      if (!match) {\n        continue;\n      }\n      const startIndex = match.index || 0;\n      const endIndex = startIndex + match[0].length;\n      let replaceNode, leftTextNode, rightTextNode;\n      if (startIndex === 0) {\n        [replaceNode, textNode] = textNode.splitText(endIndex);\n      } else {\n        [leftTextNode, replaceNode, rightTextNode] = textNode.splitText(startIndex, endIndex);\n      }\n      if (leftTextNode) {\n        importTextMatchTransformers(leftTextNode, textMatchTransformers);\n      }\n      if (rightTextNode) {\n        textNode = rightTextNode;\n      }\n      transformer.replace(replaceNode, match);\n      continue mainLoop;\n    }\n    break;\n  }\n}\n\n// Finds first \"<tag>content<tag>\" match that is not nested into another tag\nfunction findOutermostMatch(textContent, textTransformersIndex) {\n  const openTagsMatch = textContent.match(textTransformersIndex.openTagsRegExp);\n  if (openTagsMatch == null) {\n    return null;\n  }\n  for (const match of openTagsMatch) {\n    // Open tags reg exp might capture leading space so removing it\n    // before using match to find transformer\n    const tag = match.replace(/^\\s/, '');\n    const fullMatchRegExp = textTransformersIndex.fullMatchRegExpByTag[tag];\n    if (fullMatchRegExp == null) {\n      continue;\n    }\n    const fullMatch = textContent.match(fullMatchRegExp);\n    const transformer = textTransformersIndex.transformersByTag[tag];\n    if (fullMatch != null && transformer != null) {\n      if (transformer.intraword !== false) {\n        return fullMatch;\n      }\n\n      // For non-intraword transformers checking if it's within a word\n      // or surrounded with space/punctuation/newline\n      const {\n        index = 0\n      } = fullMatch;\n      const beforeChar = textContent[index - 1];\n      const afterChar = textContent[index + fullMatch[0].length];\n      if ((!beforeChar || PUNCTUATION_OR_SPACE.test(beforeChar)) && (!afterChar || PUNCTUATION_OR_SPACE.test(afterChar))) {\n        return fullMatch;\n      }\n    }\n  }\n  return null;\n}\nfunction createTextFormatTransformersIndex(textTransformers) {\n  const transformersByTag = {};\n  const fullMatchRegExpByTag = {};\n  const openTagsRegExp = [];\n  const escapeRegExp = `(?<![\\\\\\\\])`;\n  for (const transformer of textTransformers) {\n    const {\n      tag\n    } = transformer;\n    transformersByTag[tag] = transformer;\n    const tagRegExp = tag.replace(/(\\*|\\^|\\+)/g, '\\\\$1');\n    openTagsRegExp.push(tagRegExp);\n    if (IS_SAFARI || IS_IOS || IS_APPLE_WEBKIT) {\n      fullMatchRegExpByTag[tag] = new RegExp(`(${tagRegExp})(?![${tagRegExp}\\\\s])(.*?[^${tagRegExp}\\\\s])${tagRegExp}(?!${tagRegExp})`);\n    } else {\n      fullMatchRegExpByTag[tag] = new RegExp(`(?<![\\\\\\\\${tagRegExp}])(${tagRegExp})((\\\\\\\\${tagRegExp})?.*?[^${tagRegExp}\\\\s](\\\\\\\\${tagRegExp})?)((?<!\\\\\\\\)|(?<=\\\\\\\\\\\\\\\\))(${tagRegExp})(?![\\\\\\\\${tagRegExp}])`);\n    }\n  }\n  return {\n    // Reg exp to find open tag + content + close tag\n    fullMatchRegExpByTag,\n    // Reg exp to find opening tags\n    openTagsRegExp: new RegExp((IS_SAFARI || IS_IOS || IS_APPLE_WEBKIT ? '' : `${escapeRegExp}`) + '(' + openTagsRegExp.join('|') + ')', 'g'),\n    transformersByTag\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction runElementTransformers(parentNode, anchorNode, anchorOffset, elementTransformers) {\n  const grandParentNode = parentNode.getParent();\n  if (!lexical.$isRootOrShadowRoot(grandParentNode) || parentNode.getFirstChild() !== anchorNode) {\n    return false;\n  }\n  const textContent = anchorNode.getTextContent();\n\n  // Checking for anchorOffset position to prevent any checks for cases when caret is too far\n  // from a line start to be a part of block-level markdown trigger.\n  //\n  // TODO:\n  // Can have a quick check if caret is close enough to the beginning of the string (e.g. offset less than 10-20)\n  // since otherwise it won't be a markdown shortcut, but tables are exception\n  if (textContent[anchorOffset - 1] !== ' ') {\n    return false;\n  }\n  for (const {\n    regExp,\n    replace\n  } of elementTransformers) {\n    const match = textContent.match(regExp);\n    if (match && match[0].length === anchorOffset) {\n      const nextSiblings = anchorNode.getNextSiblings();\n      const [leadingNode, remainderNode] = anchorNode.splitText(anchorOffset);\n      leadingNode.remove();\n      const siblings = remainderNode ? [remainderNode, ...nextSiblings] : nextSiblings;\n      replace(parentNode, siblings, match, false);\n      return true;\n    }\n  }\n  return false;\n}\nfunction runTextMatchTransformers(anchorNode, anchorOffset, transformersByTrigger) {\n  let textContent = anchorNode.getTextContent();\n  const lastChar = textContent[anchorOffset - 1];\n  const transformers = transformersByTrigger[lastChar];\n  if (transformers == null) {\n    return false;\n  }\n\n  // If typing in the middle of content, remove the tail to do\n  // reg exp match up to a string end (caret position)\n  if (anchorOffset < textContent.length) {\n    textContent = textContent.slice(0, anchorOffset);\n  }\n  for (const transformer of transformers) {\n    const match = textContent.match(transformer.regExp);\n    if (match === null) {\n      continue;\n    }\n    const startIndex = match.index || 0;\n    const endIndex = startIndex + match[0].length;\n    let replaceNode;\n    if (startIndex === 0) {\n      [replaceNode] = anchorNode.splitText(endIndex);\n    } else {\n      [, replaceNode] = anchorNode.splitText(startIndex, endIndex);\n    }\n    replaceNode.selectNext(0, 0);\n    transformer.replace(replaceNode, match);\n    return true;\n  }\n  return false;\n}\nfunction runTextFormatTransformers(anchorNode, anchorOffset, textFormatTransformers) {\n  const textContent = anchorNode.getTextContent();\n  const closeTagEndIndex = anchorOffset - 1;\n  const closeChar = textContent[closeTagEndIndex];\n  // Quick check if we're possibly at the end of inline markdown style\n  const matchers = textFormatTransformers[closeChar];\n  if (!matchers) {\n    return false;\n  }\n  for (const matcher of matchers) {\n    const {\n      tag\n    } = matcher;\n    const tagLength = tag.length;\n    const closeTagStartIndex = closeTagEndIndex - tagLength + 1;\n\n    // If tag is not single char check if rest of it matches with text content\n    if (tagLength > 1) {\n      if (!isEqualSubString(textContent, closeTagStartIndex, tag, 0, tagLength)) {\n        continue;\n      }\n    }\n\n    // Space before closing tag cancels inline markdown\n    if (textContent[closeTagStartIndex - 1] === ' ') {\n      continue;\n    }\n\n    // Some tags can not be used within words, hence should have newline/space/punctuation after it\n    const afterCloseTagChar = textContent[closeTagEndIndex + 1];\n    if (matcher.intraword === false && afterCloseTagChar && !PUNCTUATION_OR_SPACE.test(afterCloseTagChar)) {\n      continue;\n    }\n    const closeNode = anchorNode;\n    let openNode = closeNode;\n    let openTagStartIndex = getOpenTagStartIndex(textContent, closeTagStartIndex, tag);\n\n    // Go through text node siblings and search for opening tag\n    // if haven't found it within the same text node as closing tag\n    let sibling = openNode;\n    while (openTagStartIndex < 0 && (sibling = sibling.getPreviousSibling())) {\n      if (lexical.$isLineBreakNode(sibling)) {\n        break;\n      }\n      if (lexical.$isTextNode(sibling)) {\n        const siblingTextContent = sibling.getTextContent();\n        openNode = sibling;\n        openTagStartIndex = getOpenTagStartIndex(siblingTextContent, siblingTextContent.length, tag);\n      }\n    }\n\n    // Opening tag is not found\n    if (openTagStartIndex < 0) {\n      continue;\n    }\n\n    // No content between opening and closing tag\n    if (openNode === closeNode && openTagStartIndex + tagLength === closeTagStartIndex) {\n      continue;\n    }\n\n    // Checking longer tags for repeating chars (e.g. *** vs **)\n    const prevOpenNodeText = openNode.getTextContent();\n    if (openTagStartIndex > 0 && prevOpenNodeText[openTagStartIndex - 1] === closeChar) {\n      continue;\n    }\n\n    // Some tags can not be used within words, hence should have newline/space/punctuation before it\n    const beforeOpenTagChar = prevOpenNodeText[openTagStartIndex - 1];\n    if (matcher.intraword === false && beforeOpenTagChar && !PUNCTUATION_OR_SPACE.test(beforeOpenTagChar)) {\n      continue;\n    }\n\n    // Clean text from opening and closing tags (starting from closing tag\n    // to prevent any offset shifts if we start from opening one)\n    const prevCloseNodeText = closeNode.getTextContent();\n    const closeNodeText = prevCloseNodeText.slice(0, closeTagStartIndex) + prevCloseNodeText.slice(closeTagEndIndex + 1);\n    closeNode.setTextContent(closeNodeText);\n    const openNodeText = openNode === closeNode ? closeNodeText : prevOpenNodeText;\n    openNode.setTextContent(openNodeText.slice(0, openTagStartIndex) + openNodeText.slice(openTagStartIndex + tagLength));\n    const selection = lexical.$getSelection();\n    const nextSelection = lexical.$createRangeSelection();\n    lexical.$setSelection(nextSelection);\n    // Adjust offset based on deleted chars\n    const newOffset = closeTagEndIndex - tagLength * (openNode === closeNode ? 2 : 1) + 1;\n    nextSelection.anchor.set(openNode.__key, openTagStartIndex, 'text');\n    nextSelection.focus.set(closeNode.__key, newOffset, 'text');\n\n    // Apply formatting to selected text\n    for (const format of matcher.format) {\n      if (!nextSelection.hasFormat(format)) {\n        nextSelection.formatText(format);\n      }\n    }\n\n    // Collapse selection up to the focus point\n    nextSelection.anchor.set(nextSelection.focus.key, nextSelection.focus.offset, nextSelection.focus.type);\n\n    // Remove formatting from collapsed selection\n    for (const format of matcher.format) {\n      if (nextSelection.hasFormat(format)) {\n        nextSelection.toggleFormat(format);\n      }\n    }\n    if (lexical.$isRangeSelection(selection)) {\n      nextSelection.format = selection.format;\n    }\n    return true;\n  }\n  return false;\n}\nfunction getOpenTagStartIndex(string, maxIndex, tag) {\n  const tagLength = tag.length;\n  for (let i = maxIndex; i >= tagLength; i--) {\n    const startIndex = i - tagLength;\n    if (isEqualSubString(string, startIndex, tag, 0, tagLength) &&\n    // Space after opening tag cancels transformation\n    string[startIndex + tagLength] !== ' ') {\n      return startIndex;\n    }\n  }\n  return -1;\n}\nfunction isEqualSubString(stringA, aStart, stringB, bStart, length) {\n  for (let i = 0; i < length; i++) {\n    if (stringA[aStart + i] !== stringB[bStart + i]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction registerMarkdownShortcuts(editor, transformers = TRANSFORMERS) {\n  const byType = transformersByType(transformers);\n  const textFormatTransformersIndex = indexBy(byType.textFormat, ({\n    tag\n  }) => tag[tag.length - 1]);\n  const textMatchTransformersIndex = indexBy(byType.textMatch, ({\n    trigger\n  }) => trigger);\n  for (const transformer of transformers) {\n    const type = transformer.type;\n    if (type === 'element' || type === 'text-match') {\n      const dependencies = transformer.dependencies;\n      for (const node of dependencies) {\n        if (!editor.hasNode(node)) {\n          {\n            throw Error(`MarkdownShortcuts: missing dependency ${node.getType()} for transformer. Ensure node dependency is included in editor initial config.`);\n          }\n        }\n      }\n    }\n  }\n  const transform = (parentNode, anchorNode, anchorOffset) => {\n    if (runElementTransformers(parentNode, anchorNode, anchorOffset, byType.element)) {\n      return;\n    }\n    if (runTextMatchTransformers(anchorNode, anchorOffset, textMatchTransformersIndex)) {\n      return;\n    }\n    runTextFormatTransformers(anchorNode, anchorOffset, textFormatTransformersIndex);\n  };\n  return editor.registerUpdateListener(({\n    tags,\n    dirtyLeaves,\n    editorState,\n    prevEditorState\n  }) => {\n    // Ignore updates from undo/redo (as changes already calculated)\n    if (tags.has('historic')) {\n      return;\n    }\n\n    // If editor is still composing (i.e. backticks) we must wait before the user confirms the key\n    if (editor.isComposing()) {\n      return;\n    }\n    const selection = editorState.read(lexical.$getSelection);\n    const prevSelection = prevEditorState.read(lexical.$getSelection);\n    if (!lexical.$isRangeSelection(prevSelection) || !lexical.$isRangeSelection(selection) || !selection.isCollapsed()) {\n      return;\n    }\n    const anchorKey = selection.anchor.key;\n    const anchorOffset = selection.anchor.offset;\n    const anchorNode = editorState._nodeMap.get(anchorKey);\n    if (!lexical.$isTextNode(anchorNode) || !dirtyLeaves.has(anchorKey) || anchorOffset !== 1 && anchorOffset > prevSelection.anchor.offset + 1) {\n      return;\n    }\n    editor.update(() => {\n      // Markdown is not available inside code\n      if (anchorNode.hasFormat('code')) {\n        return;\n      }\n      const parentNode = anchorNode.getParent();\n      if (parentNode === null || code.$isCodeNode(parentNode)) {\n        return;\n      }\n      transform(parentNode, anchorNode, selection.anchor.offset);\n    });\n  });\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst createBlockNode = createNode => {\n  return (parentNode, children, match) => {\n    const node = createNode(match);\n    node.append(...children);\n    parentNode.replace(node);\n    node.select(0, 0);\n  };\n};\n\n// Amount of spaces that define indentation level\n// TODO: should be an option\nconst LIST_INDENT_SIZE = 4;\nconst listReplace = listType => {\n  return (parentNode, children, match) => {\n    const previousNode = parentNode.getPreviousSibling();\n    const nextNode = parentNode.getNextSibling();\n    const listItem = list.$createListItemNode(listType === 'check' ? match[3] === 'x' : undefined);\n    if (list.$isListNode(nextNode) && nextNode.getListType() === listType) {\n      const firstChild = nextNode.getFirstChild();\n      if (firstChild !== null) {\n        firstChild.insertBefore(listItem);\n      } else {\n        // should never happen, but let's handle gracefully, just in case.\n        nextNode.append(listItem);\n      }\n      parentNode.remove();\n    } else if (list.$isListNode(previousNode) && previousNode.getListType() === listType) {\n      previousNode.append(listItem);\n      parentNode.remove();\n    } else {\n      const list$1 = list.$createListNode(listType, listType === 'number' ? Number(match[2]) : undefined);\n      list$1.append(listItem);\n      parentNode.replace(list$1);\n    }\n    listItem.append(...children);\n    listItem.select(0, 0);\n    const indent = Math.floor(match[1].length / LIST_INDENT_SIZE);\n    if (indent) {\n      listItem.setIndent(indent);\n    }\n  };\n};\nconst listExport = (listNode, exportChildren, depth) => {\n  const output = [];\n  const children = listNode.getChildren();\n  let index = 0;\n  for (const listItemNode of children) {\n    if (list.$isListItemNode(listItemNode)) {\n      if (listItemNode.getChildrenSize() === 1) {\n        const firstChild = listItemNode.getFirstChild();\n        if (list.$isListNode(firstChild)) {\n          output.push(listExport(firstChild, exportChildren, depth + 1));\n          continue;\n        }\n      }\n      const indent = ' '.repeat(depth * LIST_INDENT_SIZE);\n      const listType = listNode.getListType();\n      const prefix = listType === 'number' ? `${listNode.getStart() + index}. ` : listType === 'check' ? `- [${listItemNode.getChecked() ? 'x' : ' '}] ` : '- ';\n      output.push(indent + prefix + exportChildren(listItemNode));\n      index++;\n    }\n  }\n  return output.join('\\n');\n};\nconst HEADING = {\n  dependencies: [richText.HeadingNode],\n  export: (node, exportChildren) => {\n    if (!richText.$isHeadingNode(node)) {\n      return null;\n    }\n    const level = Number(node.getTag().slice(1));\n    return '#'.repeat(level) + ' ' + exportChildren(node);\n  },\n  regExp: /^(#{1,6})\\s/,\n  replace: createBlockNode(match => {\n    const tag = 'h' + match[1].length;\n    return richText.$createHeadingNode(tag);\n  }),\n  type: 'element'\n};\nconst QUOTE = {\n  dependencies: [richText.QuoteNode],\n  export: (node, exportChildren) => {\n    if (!richText.$isQuoteNode(node)) {\n      return null;\n    }\n    const lines = exportChildren(node).split('\\n');\n    const output = [];\n    for (const line of lines) {\n      output.push('> ' + line);\n    }\n    return output.join('\\n');\n  },\n  regExp: /^>\\s/,\n  replace: (parentNode, children, _match, isImport) => {\n    if (isImport) {\n      const previousNode = parentNode.getPreviousSibling();\n      if (richText.$isQuoteNode(previousNode)) {\n        previousNode.splice(previousNode.getChildrenSize(), 0, [lexical.$createLineBreakNode(), ...children]);\n        previousNode.select(0, 0);\n        parentNode.remove();\n        return;\n      }\n    }\n    const node = richText.$createQuoteNode();\n    node.append(...children);\n    parentNode.replace(node);\n    node.select(0, 0);\n  },\n  type: 'element'\n};\nconst CODE = {\n  dependencies: [code.CodeNode],\n  export: node => {\n    if (!code.$isCodeNode(node)) {\n      return null;\n    }\n    const textContent = node.getTextContent();\n    return '```' + (node.getLanguage() || '') + (textContent ? '\\n' + textContent : '') + '\\n' + '```';\n  },\n  regExp: /^```(\\w{1,10})?\\s/,\n  replace: createBlockNode(match => {\n    return code.$createCodeNode(match ? match[1] : undefined);\n  }),\n  type: 'element'\n};\nconst UNORDERED_LIST = {\n  dependencies: [list.ListNode, list.ListItemNode],\n  export: (node, exportChildren) => {\n    return list.$isListNode(node) ? listExport(node, exportChildren, 0) : null;\n  },\n  regExp: /^(\\s*)[-*+]\\s/,\n  replace: listReplace('bullet'),\n  type: 'element'\n};\nconst CHECK_LIST = {\n  dependencies: [list.ListNode, list.ListItemNode],\n  export: (node, exportChildren) => {\n    return list.$isListNode(node) ? listExport(node, exportChildren, 0) : null;\n  },\n  regExp: /^(\\s*)(?:-\\s)?\\s?(\\[(\\s|x)?\\])\\s/i,\n  replace: listReplace('check'),\n  type: 'element'\n};\nconst ORDERED_LIST = {\n  dependencies: [list.ListNode, list.ListItemNode],\n  export: (node, exportChildren) => {\n    return list.$isListNode(node) ? listExport(node, exportChildren, 0) : null;\n  },\n  regExp: /^(\\s*)(\\d{1,})\\.\\s/,\n  replace: listReplace('number'),\n  type: 'element'\n};\nconst INLINE_CODE = {\n  format: ['code'],\n  tag: '`',\n  type: 'text-format'\n};\nconst HIGHLIGHT = {\n  format: ['highlight'],\n  tag: '==',\n  type: 'text-format'\n};\nconst BOLD_ITALIC_STAR = {\n  format: ['bold', 'italic'],\n  tag: '***',\n  type: 'text-format'\n};\nconst BOLD_ITALIC_UNDERSCORE = {\n  format: ['bold', 'italic'],\n  intraword: false,\n  tag: '___',\n  type: 'text-format'\n};\nconst BOLD_STAR = {\n  format: ['bold'],\n  tag: '**',\n  type: 'text-format'\n};\nconst BOLD_UNDERSCORE = {\n  format: ['bold'],\n  intraword: false,\n  tag: '__',\n  type: 'text-format'\n};\nconst STRIKETHROUGH = {\n  format: ['strikethrough'],\n  tag: '~~',\n  type: 'text-format'\n};\nconst ITALIC_STAR = {\n  format: ['italic'],\n  tag: '*',\n  type: 'text-format'\n};\nconst ITALIC_UNDERSCORE = {\n  format: ['italic'],\n  intraword: false,\n  tag: '_',\n  type: 'text-format'\n};\n\n// Order of text transformers matters:\n//\n// - code should go first as it prevents any transformations inside\n// - then longer tags match (e.g. ** or __ should go before * or _)\nconst LINK = {\n  dependencies: [link.LinkNode],\n  export: (node, exportChildren, exportFormat) => {\n    if (!link.$isLinkNode(node)) {\n      return null;\n    }\n    const title = node.getTitle();\n    const linkContent = title ? `[${node.getTextContent()}](${node.getURL()} \"${title}\")` : `[${node.getTextContent()}](${node.getURL()})`;\n    const firstChild = node.getFirstChild();\n    // Add text styles only if link has single text node inside. If it's more\n    // then one we ignore it as markdown does not support nested styles for links\n    if (node.getChildrenSize() === 1 && lexical.$isTextNode(firstChild)) {\n      return exportFormat(firstChild, linkContent);\n    } else {\n      return linkContent;\n    }\n  },\n  importRegExp: /(?:\\[([^[]+)\\])(?:\\((?:([^()\\s]+)(?:\\s\"((?:[^\"]*\\\\\")*[^\"]*)\"\\s*)?)\\))/,\n  regExp: /(?:\\[([^[]+)\\])(?:\\((?:([^()\\s]+)(?:\\s\"((?:[^\"]*\\\\\")*[^\"]*)\"\\s*)?)\\))$/,\n  replace: (textNode, match) => {\n    const [, linkText, linkUrl, linkTitle] = match;\n    const linkNode = link.$createLinkNode(linkUrl, {\n      title: linkTitle\n    });\n    const linkTextNode = lexical.$createTextNode(linkText);\n    linkTextNode.setFormat(textNode.getFormat());\n    linkNode.append(linkTextNode);\n    textNode.replace(linkNode);\n  },\n  trigger: ')',\n  type: 'text-match'\n};\n\n/** @module @lexical/markdown */\nconst ELEMENT_TRANSFORMERS = [HEADING, QUOTE, CODE, UNORDERED_LIST, ORDERED_LIST];\n\n// Order of text format transformers matters:\n//\n// - code should go first as it prevents any transformations inside\n// - then longer tags match (e.g. ** or __ should go before * or _)\nconst TEXT_FORMAT_TRANSFORMERS = [INLINE_CODE, BOLD_ITALIC_STAR, BOLD_ITALIC_UNDERSCORE, BOLD_STAR, BOLD_UNDERSCORE, HIGHLIGHT, ITALIC_STAR, ITALIC_UNDERSCORE, STRIKETHROUGH];\nconst TEXT_MATCH_TRANSFORMERS = [LINK];\nconst TRANSFORMERS = [...ELEMENT_TRANSFORMERS, ...TEXT_FORMAT_TRANSFORMERS, ...TEXT_MATCH_TRANSFORMERS];\nfunction $convertFromMarkdownString(markdown, transformers = TRANSFORMERS, node) {\n  const importMarkdown = createMarkdownImport(transformers);\n  return importMarkdown(markdown, node);\n}\nfunction $convertToMarkdownString(transformers = TRANSFORMERS, node) {\n  const exportMarkdown = createMarkdownExport(transformers);\n  return exportMarkdown(node);\n}\n\nexports.$convertFromMarkdownString = $convertFromMarkdownString;\nexports.$convertToMarkdownString = $convertToMarkdownString;\nexports.BOLD_ITALIC_STAR = BOLD_ITALIC_STAR;\nexports.BOLD_ITALIC_UNDERSCORE = BOLD_ITALIC_UNDERSCORE;\nexports.BOLD_STAR = BOLD_STAR;\nexports.BOLD_UNDERSCORE = BOLD_UNDERSCORE;\nexports.CHECK_LIST = CHECK_LIST;\nexports.CODE = CODE;\nexports.ELEMENT_TRANSFORMERS = ELEMENT_TRANSFORMERS;\nexports.HEADING = HEADING;\nexports.HIGHLIGHT = HIGHLIGHT;\nexports.INLINE_CODE = INLINE_CODE;\nexports.ITALIC_STAR = ITALIC_STAR;\nexports.ITALIC_UNDERSCORE = ITALIC_UNDERSCORE;\nexports.LINK = LINK;\nexports.ORDERED_LIST = ORDERED_LIST;\nexports.QUOTE = QUOTE;\nexports.STRIKETHROUGH = STRIKETHROUGH;\nexports.TEXT_FORMAT_TRANSFORMERS = TEXT_FORMAT_TRANSFORMERS;\nexports.TEXT_MATCH_TRANSFORMERS = TEXT_MATCH_TRANSFORMERS;\nexports.TRANSFORMERS = TRANSFORMERS;\nexports.UNORDERED_LIST = UNORDERED_LIST;\nexports.registerMarkdownShortcuts = registerMarkdownShortcuts;\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict'\nconst LexicalMarkdown = process.env.NODE_ENV === 'development' ? require('./LexicalMarkdown.dev.js') : require('./LexicalMarkdown.prod.js')\nmodule.exports = LexicalMarkdown;"],
  "mappings": "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",
  "names": ["list", "exportChildren"]
}
